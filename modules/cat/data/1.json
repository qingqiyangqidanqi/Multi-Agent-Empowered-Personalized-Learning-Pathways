{
"data": [
{
"knowledge_point_type": "数据结构基本概念",
"question": "数据结构是一门研究非数值计算的程序设计问题中的操作对象以及它们之间的（）和运算的学科。",
"option_A": "结构",
"option_B": "关系",
"option_C": "运算",
"option_D": "算法",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "数据结构基本概念",
"question": "在数据结构中，从逻辑上可以把数据结构分成（）。",
"option_A": "动态结构和静态结构",
"option_B": "紧凑结构和非紧凑结构",
"option_C": "线性结构和非线性结构",
"option_D": "逻辑结构和存储结构",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "数据结构基本概念",
"question": "线性表的逻辑顺序和存储顺序总是一致的，这种说法（）。",
"option_A": "正确",
"option_B": "不正确",
"option_C": "无法确定",
"option_D": "以上答案都不对",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "数据结构基本概念",
"question": "算法分析的目的是（）。",
"option_A": "找出算法的合理性",
"option_B": "研究算法的输入与输出关系",
"option_C": "分析算法的有效性以求改进",
"option_D": "分析算法的易懂性",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "数据结构基本概念",
"question": "算法的时间复杂度取决于（ ）",
"option_A": "问题的规模",
"option_B": "待处理数据的初态",
"option_C": "A 和 B",
"option_D": "",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "数据结构基本概念",
"question": "一个算法应该是（ ）。",
"option_A": "程序",
"option_B": "问题求解步骤的描述",
"option_C": "要满足五个基本特性",
"option_D": "A 和 C",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "数据结构基本概念",
"question": "下面关于算法说法错误的是（ ）",
"option_A": "算法最终必须由计算机程序实现",
"option_B": "为解决某问题的算法与为该问题编写的程序含义是相同的",
"option_C": "算法的可行性是指指令不能有二义性",
"option_D": "以上几个都是错误的",
"answer": "D",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "数据结构基本概念",
"question": "以下与数据的存储结构无关的术语是（ ）。",
"option_A": "循环队列",
"option_B": "链表",
"option_C": "哈希表",
"option_D": "栈",
"answer": "D",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "数据结构基本概念",
"question": "在下面的程序段中，对 x 的赋值语句的频度为（ ）\nfor（i=0;i<n;i++）\n for (j=0;j<n;j++) \n x=x+1;",
"option_A": "2n",
"option_B": "n",
"option_C": "n²",
"option_D": "log₂n",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "数据结构基本概念",
"question": "以下数据结构中，（ ）是非线性数据结构",
"option_A": "树",
"option_B": "字符串",
"option_C": "队列",
"option_D": "栈",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "数据结构基本概念",
"question": "下列数据中，（ ）是线性数据结构。",
"option_A": "哈夫曼树",
"option_B": "有向无环图",
"option_C": "二叉排序树",
"option_D": "栈",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "数据结构基本概念",
"question": "以下属于逻辑结构的是（ ）。",
"option_A": "顺序表",
"option_B": "哈希表",
"option_C": "有序表",
"option_D": "单链表",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表",
"question": "在一个长度为 n 的顺序表中删除第 i 个元素（0<i<=n）时，需要向前移动 ( ) 个元素。",
"option_A": "n-i",
"option_B": "n-i+1",
"option_C": "n-i-1",
"option_D": "i+1",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表",
"question": "从一个具有 n 个元素的线性表中查找其值等于 x 的结点时，在查找成功的情况下，需平均比较 ( ) 个元素结点。",
"option_A": "n/2",
"option_B": "n",
"option_C": "(n-1)/2",
"option_D": "(n +1)/2",
"answer": "D",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表",
"question": "对一个具有 n 个元素的线性表，建立其单链表的时间复杂度为 ( )。",
"option_A": "O (n)",
"option_B": "O (1)",
"option_C": "O (n²）",
"option_D": "O（log₂n）",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表",
"question": "线性表采用链式存储时，其地址 ( )。",
"option_A": "必须是连续的",
"option_B": "一定是不连续的",
"option_C": "部分地址必须连续",
"option_D": "连续与否均可以",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "线性表",
"question": "在一个具有 n 个结点的有序单链表中插入一个新的结点，使得链表仍然有序，该算法的时间复杂度是 ( )。",
"option_A": "O（log₂n）",
"option_B": "O（1）",
"option_C": "O（n²）",
"option_D": "O（n）",
"answer": "D",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表",
"question": "线性表是 ( )。",
"option_A": "一个有限序列，可以为空",
"option_B": "一个有限序列，不可以为空",
"option_C": "一个无限序列，可以为空",
"option_D": "一个无限序列，不可以为空",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "线性表",
"question": "在一个长度为 n 的顺序表中，向第 i 个位置（0≤i≤n＋1）插入一个新元素时，需要向后移动 ( ) 个元素。",
"option_A": "n-i",
"option_B": "n-i＋1",
"option_C": "n－i－1",
"option_D": "i＋1",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表",
"question": "如果某链表中最常用的操作是取第 i 个结点及其前驱，则采用 ( ) 存储方式最节省时间。",
"option_A": "单链表",
"option_B": "双向链表",
"option_C": "单循环链表",
"option_D": "顺序表",
"answer": "D",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "线性表",
"question": "一个顺序存储线性表的第一个元素的存储地址是 90，每个元素的长度是 2，则第 6 个元素的存储地址是（）。",
"option_A": "98",
"option_B": "100",
"option_C": "102",
"option_D": "106",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表",
"question": "在顺序存储的线性表（a1……an）中，删除任意一个结点所需移动结点的平均移动次数为 ( )",
"option_A": "n",
"option_B": "n／2",
"option_C": "(n-1)/2",
"option_D": "（n＋l）/2",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表",
"question": "在线性表的下列存储结构中，读取第 i 个元素花费的时间最少的是（）。",
"option_A": "单链表",
"option_B": "双链表",
"option_C": "循环链表",
"option_D": "顺序表",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "线性表",
"question": "若某链表中最常用的操作为在最后一个结点之后插入一个结点和删除最后一个结点，则采用（）存储方式最节省时间。",
"option_A": "双链表",
"option_B": "单链表",
"option_C": "单循环链表",
"option_D": "带头结点的双循环链表",
"answer": "D",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "线性表",
"question": "在单链表中删除指针 p 所指结点的后继结点，则执行（ ）操作。",
"option_A": "p->next=p->next->next",
"option_B": "p->next=p->next",
"option_C": "p=p->next->next",
"option_D": "p=p->next; p->next=p->next->next",
"answer": "A",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表",
"question": "在一个单链表中，已知 q 所指结点是 p 所指结点的前驱，若在 q 和 p 之间插入 s 所指的结点，则执行（ ）操作。",
"option_A": "s->next=p->next; p->next=s",
"option_B": "q->next=s; s->next=p",
"option_C": "p->next=s->next; s->next=p",
"option_D": "p->next=s; s->next=q",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表",
"question": "在单链表中附加头结点的目的是为了（ ）。",
"option_A": "保证单链表中至少有一个节点",
"option_B": "标识单链表中首结点的位置",
"option_C": "方便运算的实现",
"option_D": "说明单链表是线性表的链式存储",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表",
"question": "循环单链表的主要优点是（ ）。",
"option_A": "不再需要头指针了",
"option_B": "从表中任意一个结点出发都能扫描到整个链表",
"option_C": "已知某个结点的位置后，能够容易找到它的前驱",
"option_D": "在进行插入、删除操作时，能更好地保证链表不断开",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表",
"question": "非空的循环单链表 L 的尾结点 p 满足（ ）。",
"option_A": "p->next=NULL",
"option_B": "p=NULL",
"option_C": "p->next=L",
"option_D": "p=L",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表",
"question": "在双向循环链表中，在 p 指针所指向的结点前插入一个指针 q 所指向的新结点，其修改指针的操作是 ( )。注：双向链表的结点结构为 (prior,data,next)。",
"option_A": "p->prior=q； q->next=p； p->prior->next=q； q->prior=q；",
"option_B": "p->prior=q； p->prior->next=q; q->next=p； q->prior=p->prior；",
"option_C": "q->next=p； q->prior=p->prior；p->prior->next=q; p->prior=q;",
"option_D": "q->prior=p->prior； q->next=p； p->prior=q； p->prior=q；",
"answer": "C",
"difficulty": 7,
"bloom_level": "c"
},
{
"knowledge_point_type": "线性表",
"question": "在双向链表存储结构中，删除 p 所指的结点时须修改指针（ ）。",
"option_A": "p->prior->next=p->next; p->next->prior=p->prior;",
"option_B": "p->prior=p->prior->prior; p->prior->next=p;(删 p 的前趋)",
"option_C": "p->next->prior=p; p->next=p->next->next;",
"option_D": "p->next= p->prior->prior; p->prior= p->next->next;",
"answer": "A",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "栈和队列",
"question": "一个栈的输入序列是：a，b，c，d，e，则栈的不可能输出的序列是（）。",
"option_A": "a，b，c，d，e",
"option_B": "d，e，c，b，a",
"option_C": "d，c，e，a，b",
"option_D": "e，d，c，b，a",
"answer": "C",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "栈和队列",
"question": "若一个栈的输入序列是 1，2，3，…，n，输出序列的第一个元素是 n，则第 k 个输出元素是（ ）。",
"option_A": "k",
"option_B": "n-k-1",
"option_C": "n-k+1",
"option_D": "不确定",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "栈和队列",
"question": "判定一个栈 S（最多有 n 个元素）为空的条件是（ ）。",
"option_A": "S->top！＝0",
"option_B": "S->top= =0",
"option_C": "S->top!=n",
"option_D": "S->top= =n",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈和队列",
"question": "判定一个栈 S（最多有 n 个元素）为满的条件是（ ）。",
"option_A": "S->top!=0",
"option_B": "S->top= =0",
"option_C": "S->top!=n",
"option_D": "S->top= =n",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈和队列",
"question": " 向一个栈顶指针为 top 的不带头结点的链栈中插入一个S 结点的时候，应当执行语句（ ）。",
"option_A": "top->next=S；",
"option_B": "S->next=top；top=S；",
"option_C": "S->next＝top->next；top->next＝S；",
"option_D": "S->next＝top；top＝S->next；",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "栈和队列",
"question": " 向一个带头结点、栈顶指针为 top 的链栈中插入一个S 结点的时候，应当执行语句（ ）。",
"option_A": "top->next=S；",
"option_B": "S->next=top；top=S；",
"option_C": "S->next=top->next；top->next=S；",
"option_D": "S->next=top；top=S->next；",
"answer": "C",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "栈和队列",
"question": "判定一个队列 Q（最多有 n 个元素）为空的条件是（ ）。",
"option_A": "Q->rear-Q->front= =n",
"option_B": "Q->rear-Q->front+1= =n",
"option_C": "Q->rear = = Q->front",
"option_D": "Q->rear +1= = Q->front",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "栈和队列",
"question": "判定一个队列 Q（最多有 n 个元素）为满的条件是（）。",
"option_A": "Q->rear-Q->front= =n",
"option_B": "Q->rear-Q->front+1= =n",
"option_C": "Q->rear = = Q->front",
"option_D": "Q->rear +1= = Q->front",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "栈和队列",
"question": "判定一个循环队列 Q（最多有 n 个元素）为空的条件是（ ）。",
"option_A": "Q->rear = = Q->front",
"option_B": "Q->rear = = Q->front＋l",
"option_C": "Q->front= =(Q->rear +1)％n",
"option_D": "Q->front= =(Q->rear -1)％n",
"answer": "A",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "栈和队列",
"question": "判定一个循环队列 Q（最多有 n 个元素）为满的条件是（ ）。",
"option_A": "Q->rear = = Q->front",
"option_B": "Q->rear = = Q->front＋l",
"option_C": "Q->front= =(Q->rear +1)％n",
"option_D": "Q->front= =(Q->rear -1)％n",
"answer": "C",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "栈和队列",
"question": "在一个链队列中，假定 front 和 rear 分别为头指针和尾指针，则插入一个结点 * S 的操作是（ ）。",
"option_A": "front＝front->next",
"option_B": "S->next=rear；rear=S",
"option_C": "rear->next=S；rear=S",
"option_D": "S->next=front；front＝S",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "栈和队列",
"question": "在一个链队列中，假定 front 和 rear 分别为头指针和尾指针，删除一个结点的操作是（ ）。",
"option_A": "front=front->next",
"option_B": "rear=rear->next",
"option_C": "rear->next=front",
"option_D": "front->next＝rear",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "栈和队列",
"question": "栈与队列都是（ ）。",
"option_A": "链式存储的线性结构",
"option_B": "链式存储的非线性结构",
"option_C": "限制存取点的线性结构",
"option_D": "限制存取点的非线性结构",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈和队列",
"question": "若进栈序列为 l，2，3，4，则（ ）不可能是一个出栈序列。",
"option_A": "3，2，4，1",
"option_B": "l，2，3，4",
"option_C": "4，2，3，1",
"option_D": "4，3，2，l",
"answer": "C",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "栈和队列",
"question": "在解决计算机主机与打印机之间速度不匹配问题时通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则从该缓冲区中取走数据打印。该缓冲区应该是一个（ ）结构。",
"option_A": "堆栈",
"option_B": "队列",
"option_C": "数组",
"option_D": "线性表",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "字符串",
"question": "空串与空格串（ ）。",
"option_A": "相同",
"option_B": "不相同",
"option_C": "可能相同",
"option_D": "无法确定",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "字符串",
"question": "设有两个串 S1 与 S2，求串 S2 在 S1 中首次出现位置的运算称作（ ）。",
"option_A": "连接",
"option_B": "求子串",
"option_C": "模式匹配",
"option_D": "判子串",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "字符串",
"question": "串与普通的线性表相比较，它的特殊性体现在（ ）。",
"option_A": "顺序的存储结构",
"option_B": "链接的存储结构",
"option_C": "数据元素是一个字符",
"option_D": "数据元素可以任意",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "字符串",
"question": "设有串 S=‘Computer’，则其子串的数目是（ ）。",
"option_A": "36",
"option_B": "37",
"option_C": "8",
"option_D": "9",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "数组和广义表",
"question": "数组常用的两种基本操作是（ ）。",
"option_A": "建立与查找",
"option_B": "删除与查找",
"option_C": "插入与索引",
"option_D": "查找与修改",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "数组和广义表",
"question": "对稀疏矩阵进行压缩存储，常用的两种方法是（ ）。",
"option_A": "二元组和散列表",
"option_B": "三元组表和十字链表",
"option_C": "三角矩阵和对角矩阵",
"option_D": "对角矩阵和十字链表",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "数组和广义表",
"question": "采用稀疏矩阵的三元组表形式进行压缩存储，若要完成对三元组表进行转置，只要将行和列对换，这种说法（ ）。",
"option_A": "正确",
"option_B": "错误",
"option_C": "无法确定",
"option_D": "以上均不对",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "数组和广义表",
"question": "一个广义表的表头总是一个广义表，这种说法（ ）。",
"option_A": "正确",
"option_B": "错误",
"option_C": "无法确定",
"option_D": "以上均不对",
"answer": "B",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "数组和广义表",
"question": "一个广义表的表尾总是一个广义表，这种说法（ ）。",
"option_A": "正确",
"option_B": "错误",
"option_C": "无法确定",
"option_D": "以上均不对",
"answer": "A",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "数组和广义表",
"question": "广义表 ((a)) 的表头是（ ）。",
"option_A": "（ ）",
"option_B": "a",
"option_C": "（a）",
"option_D": "（（a））",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "数组和广义表",
"question": "广义表（（a））的表尾是（ ）。",
"option_A": "（）",
"option_B": "a",
"option_C": "（a）",
"option_D": "（（a））",
"answer": "A",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "数组和广义表",
"question": "广义表（（a），a）的表头是（ ）。",
"option_A": "（ ）",
"option_B": "a",
"option_C": "（a）",
"option_D": "（（a））",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "数组和广义表",
"question": "广义表（（a），a）的表尾是（ ）。",
"option_A": "( )",
"option_B": "a",
"option_C": "（a）",
"option_D": "（（a））",
"answer": "C",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "数组和广义表",
"question": "广义表（a，b，c）的表头是（ ）。",
"option_A": "a",
"option_B": "（a）",
"option_C": "a，b",
"option_D": "（b，c）",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "数组和广义表",
"question": "广义表（a，b，c）的表尾是（ ）。",
"option_A": "b，c",
"option_B": "（b，c）",
"option_C": "a．b，c",
"option_D": "（a，b，c）",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "数组和广义表",
"question": "广义表 A 满足 Head（A）= Tail（A），则 A 为（）。",
"option_A": "（）",
"option_B": "（（））",
"option_C": "（（），（））",
"option_D": "（（），（），（））",
"answer": "B",
"difficulty": 7,
"bloom_level": "d"
},
{
"knowledge_point_type": "树和二叉树",
"question": "在二叉树后序遍历中，任一个结点均在其子女结点后面，这种说法（ ）。",
"option_A": "正确",
"option_B": "不正确",
"option_C": "无法判断",
"option_D": "以上均不对",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "树和二叉树",
"question": "在二叉树先序遍历中，任一个结点均在其子女结点前面，这种说法（ ）。",
"option_A": "正确",
"option_B": "不正确",
"option_C": "无法判断",
"option_D": "以上均不对",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "树和二叉树",
"question": "设深度为 h 的二叉树上只有叶子结点和同时具有左右子树的结点，则此类二叉树中所包含的结点数目至少为（ ）。",
"option_A": "2h",
"option_B": "2h",
"option_C": "2h＋1",
"option_D": "2h-l",
"answer": "D",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "树和二叉树",
"question": "二叉树第 k 层上最多有（ ）个结点。",
"option_A": "2k",
"option_B": "2k-1",
"option_C": "2^(k-1)",
"option_D": "2^(k+1)",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "树和二叉树",
"question": "二叉树的深度为 k，则二叉树最多有（ ）个结点。",
"option_A": "2k",
"option_B": "2k-1",
"option_C": "2^k-1",
"option_D": "2^k -1",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "树和二叉树",
"question": "设某一二叉树先序遍历为 abdec，中序遍历为 dbeac，则该二叉树后序遍历的顺序是（ ）。",
"option_A": "abdec",
"option_B": "debac",
"option_C": "debca",
"option_D": "abedc",
"answer": "C",
"difficulty": 7,
"bloom_level": "d"
},
{
"knowledge_point_type": "树和二叉树",
"question": "设某一二叉树中序遍历为 badce，后序遍历为 bdeca，则该二叉树先序遍历的顺序是（ ）。",
"option_A": "adbec",
"option_B": "decab",
"option_C": "debac",
"option_D": "abode",
"answer": "D",
"difficulty": 7,
"bloom_level": "d"
},
{
"knowledge_point_type": "树和二叉树",
"question": "将一棵树 T 转换为一棵二叉树 T2，则 T 的先序遍历是 T2 的（ ）。",
"option_A": "先序",
"option_B": "中序",
"option_C": "后序",
"option_D": "无法确定",
"answer": "A",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "树和二叉树",
"question": "将一棵树 T 转换为一棵二叉树 T2，则 T 的后序遍历是 T2 的（ ）。",
"option_A": "先序",
"option_B": "中序",
"option_C": "后序",
"option_D": "无法确定",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "树和二叉树",
"question": "树最适合于用来表示（ ）。",
"option_A": "线性结构的数据",
"option_B": "顺序结构的数据",
"option_C": "元素之间无前驱和后继关系的数据",
"option_D": "元素之间有包含和层次关系的数据",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "树和二叉树",
"question": "二叉树的叶子结点在先序、中序和后序遍历过程中的相对秩序（ ）。",
"option_A": "发生改变",
"option_B": "不发生改变",
"option_C": "无法确定",
"option_D": "以上均不正确",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "树和二叉树",
"question": "设一棵二叉树度为 2 的结点数是 7，度为 1 的结点数是 6，则叶子结点数是（ ）。",
"option_A": "6",
"option_B": "7",
"option_C": "8",
"option_D": "9",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "树和二叉树",
"question": "用顺序存储的方法，将完全二叉树中所有结点按层逐个从左到右的顺序存放在一维数组 R [1．．n] 中，若结点 R [i] 有左孩子，则其左孩子是（ ）。",
"option_A": "R [2i-1]",
"option_B": "R [2i+1]",
"option_C": "R [2i]",
"option_D": "R [2/i]",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "树和二叉树",
"question": "用顺序存储的方法，将完全二叉树中所有结点按层逐个从左到右的顺序存放在一维数组 R [1．．n] 中，若结点 R [i] 有右孩子，则其右孩子是（ ）。",
"option_A": "R [2i-1]",
"option_B": "R [2i＋l]",
"option_C": "R [2i]",
"option_D": "R [2/i]",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "树和二叉树",
"question": "一棵非空的二叉树，先序遍历与后序遍历正好相反，则该二叉树满足（ ）。",
"option_A": "无左孩子",
"option_B": "无右孩子",
"option_C": "只有一个叶子结点",
"option_D": "任意二叉树",
"answer": "C",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "树和二叉树",
"question": "设 a、b 为一棵二叉树的两个结点，在后序遍历中，a 在 b 前的条件是（ ）。",
"option_A": "a 在 b 上方",
"option_B": "a 在 b 下方",
"option_C": "a 在 b 左方",
"option_D": "a 在 b 右方",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "树和二叉树",
"question": "线索二叉树是一种（ ）。",
"option_A": "逻辑结构",
"option_B": "线性结构",
"option_C": "逻辑和线性结构",
"option_D": "物理结构",
"answer": "D",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "树和二叉树",
"question": "N 个结点的线索二叉树中，线索的数目是（ ）。",
"option_A": "N-1",
"option_B": "N＋1",
"option_C": "2N",
"option_D": "2N－1",
"answer": "B",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "树和二叉树",
"question": "权值为｛l，2，6，8｝的四个结点构成的哈夫曼树的带权路径长度是（ ）。",
"option_A": "18",
"option_B": "28",
"option_C": "19",
"option_D": "29",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "树和二叉树",
"question": "实现任意二叉树的后序遍历的非递归算法而不使用栈结构，最佳方案是二叉树采用（ ）存储结构。",
"option_A": "二叉链表",
"option_B": "广义表存储结构",
"option_C": "三叉链表",
"option_D": "顺序存储结构",
"answer": "C",
"difficulty": 7,
"bloom_level": "d"
},
{
"knowledge_point_type": "树和二叉树",
"question": "对一个满二叉树，m 个树叶，k 个分枝结点，n 个结点，则（ ）。",
"option_A": "n＝m＋1",
"option_B": "m+1=2n",
"option_C": "m＝k-1",
"option_D": "n=2k+1",
"answer": "D",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "树和二叉树",
"question": "具有五层结点的二叉平衡树至少有（ ）个结点。",
"option_A": "10",
"option_B": "12",
"option_C": "15",
"option_D": "17",
"answer": "B",
"difficulty": 7,
"bloom_level": "d"
},
{
"knowledge_point_type": "树和二叉树",
"question": "设 n，m 为一棵二叉树上的二个结点，在中序遍历时，n 在 m 前的条件是（ ）。",
"option_A": "n 在 m 右方",
"option_B": "n 是 m 祖先",
"option_C": "n 在 m 左方",
"option_D": "n 是 m 子孙",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "树和二叉树",
"question": "线索二叉树是一种（ ）结构。",
"option_A": "逻辑",
"option_B": "逻辑和物理",
"option_C": "物理",
"option_D": "线性",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "树和二叉树",
"question": "将一棵有 100 个结点的完全二叉树从根这一层开始，每一层上从左到右依次对结点进行编号，根结点的编号为 1，则编号为 49 的结点的左孩子编号为（ ）。",
"option_A": "98",
"option_B": "99",
"option_C": "50",
"option_D": "48",
"answer": "A",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "图",
"question": "在一个无向图 G 中，所有顶点的度数之和等于所有边数之和的（ ）倍。",
"option_A": "l/2",
"option_B": "1",
"option_C": "2",
"option_D": "4",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "图",
"question": "在一个有向图中，所有顶点的入度之和等于所有顶点的出度之和的（）倍。",
"option_A": "l/2",
"option_B": "1",
"option_C": "2",
"option_D": "4",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "图",
"question": "一个具有 n 个顶点的无向连通图至少包含（ ）条边。",
"option_A": "n",
"option_B": "n＋1",
"option_C": "n-1",
"option_D": "n/2",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "图",
"question": "一个具有 n 个顶点的无向完全图包含（ ）条边。",
"option_A": "n (n-l)",
"option_B": "n (n+l)",
"option_C": "n (n-l)/2",
"option_D": "n (n+l)/2",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "图",
"question": "一个具有 n 个顶点的有向完全图包含（ ）条边。",
"option_A": "n (n-1)",
"option_B": "n (n+l)",
"option_C": "n (n-l)/2",
"option_D": "n (n+l)/2",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "图",
"question": "对于具有 n 个顶点的图，若采用邻接矩阵表示，则该矩阵的大小为（ ）。",
"option_A": "n",
"option_B": "n²",
"option_C": "n-1",
"option_D": "(n-l)²",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "图",
"question": "对于一个具有 n 个顶点和 e 条边的无向图，若采用邻接表表示，则表头向量的大小为（ ）。",
"option_A": "n",
"option_B": "e",
"option_C": "2n",
"option_D": "2e",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "图",
"question": "对于一个具有 n 个顶点和 e 条边的无向图，若采用邻接表表示，则所有顶点邻接表中的结点总数为（ ）。",
"option_A": "n",
"option_B": "e",
"option_C": "2n",
"option_D": "2e",
"answer": "D",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "图",
"question": "在有向图的邻接表中，每个顶点邻接链表链接着该顶点所有（ ）邻接点。",
"option_A": "入边",
"option_B": "出边",
"option_C": "入边和出边",
"option_D": "不是入边也不是出边",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "图",
"question": "在有向图的逆邻接表中，每个顶点邻接链表链接着该顶点所有（ ）邻接点。",
"option_A": "入边",
"option_B": "出边",
"option_C": "入边和出边",
"option_D": "不是入边也不是出边",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "图",
"question": "下列说法中不正确的是（ ）。",
"option_A": "无向图中的极大连通子图称为连通分量",
"option_B": "连通图的广度优先搜索中一般要采用队列来暂存刚访问过的顶点",
"option_C": "图的深度优先搜索中一般要采用栈来暂存刚访问过的顶点",
"option_D": "有向图的遍历不可采用广度优先搜索方法",
"answer": "D",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "图",
"question": "设无向连通图 G=(V, E) 和 G’= (V’, E’)，如果 G’为 G 的生成树，则下列说法中不正确的是（ ）。",
"option_A": "G’为 G 的连通分量",
"option_B": "G’为 G 的无环子图",
"option_C": "G’为 G 的子图",
"option_D": "G’为 G 的极小连通子图且 V’＝V",
"answer": "A",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "图",
"question": "如果无向图 G 必须进行二次广度优先搜索才能访问其所有顶点，则下列说法中不正确的是（ ）。",
"option_A": "G 肯定不是完全图",
"option_B": "G 一定不是连通图",
"option_C": "G 中一定有回路",
"option_D": "G 有二个连通分量",
"answer": "C",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "图",
"question": "邻接表是图的一种（ ）。",
"option_A": "顺序存储结构",
"option_B": "链式存储结构",
"option_C": "索引存储结构",
"option_D": "散列存储结构",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "图",
"question": "如果从无向图的任一顶点出发进行一次深度优先搜索即可访问所有顶点，则该图一定是（ ）。",
"option_A": "完全图",
"option_B": "连通图",
"option_C": "有回路",
"option_D": "一棵树",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "图",
"question": "下列有关图遍历的说法不正确的是（ ）。",
"option_A": "连通图的深度优先搜索是一个递归过程",
"option_B": "图的广度优先搜索中邻接点的寻找具有 “先进先出” 的特征",
"option_C": "非连通图不能用深度优先搜索法",
"option_D": "图的遍历要求每一顶点仅被访问一次",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "图",
"question": "一个无向连通图的生成树是含有该连通图的全部顶点的（ ）。",
"option_A": "极小连通子图",
"option_B": "极小子图",
"option_C": "极大连通子图",
"option_D": "极大子图",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "图",
"question": "无向图的邻接矩阵是一个（ ）。",
"option_A": "对称矩阵",
"option_B": "零矩阵",
"option_C": "上三角矩阵",
"option_D": "对角矩阵",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "图",
"question": "已知一个图如下图所示，若从顶点 a 出发按深度优先搜索法进行遍历，则可能得到的一种顶点序列为（ ）。",
"option_A": "abecdf",
"option_B": "acfebd",
"option_C": "acebfd",
"option_D": "acfdeb",
"answer": "C",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "查找",
"question": "顺序查找方法适合于存储结构为（ ）的线性表",
"option_A": "散列存储",
"option_B": "索引存储",
"option_C": "散列存储或索引存储",
"option_D": "顺序存储或链接存储",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "查找",
"question": "对线性表进行二分查找的时候，要求线性表必须（ ）。",
"option_A": "以顺序存储方式",
"option_B": "以链接存储方式",
"option_C": "以顺序存储方式，且数据元素有序",
"option_D": "以链接存储方式，且数据元素有序",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "查找",
"question": "如果要求一个线性表既能较快地查找，又能动态适应变化要求，可以采用（ ）查找方法。",
"option_A": "顺序",
"option_B": "分块",
"option_C": "折半",
"option_D": "散列",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "查找",
"question": "对于一个线性表，若要求既能进行较快地插入和删除，又要求存储结构能够反映数据元素之间的逻辑关系，则应该 ( ) 。",
"option_A": "以顺序存储方式",
"option_B": "以链接存储方式",
"option_C": "以索引存储方式",
"option_D": "以散列存储方式",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "查找",
"question": "在线性表的存储结构中，（ ）查找、插入和删除速度慢，但顺序存储和随机存取第 i 个元素速度快。",
"option_A": "顺序表",
"option_B": "链接表",
"option_C": "散列表",
"option_D": "索引表",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "查找",
"question": "在 ( ) 上查找和存取速度快，但插入和删除速度慢。",
"option_A": "顺序表",
"option_B": "链接表",
"option_C": "顺序有序表",
"option_D": "散列表",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "查找",
"question": "在 ( ) 上查找、插入和删除速度快，但不能进行顺序存取。",
"option_A": "顺序表",
"option_B": "链接表",
"option_C": "顺序有序表",
"option_D": "散列表",
"answer": "D",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "查找",
"question": "在 ( ) 上插入、删除和顺序存取速度快，但查找速度慢。",
"option_A": "顺序表",
"option_B": "链接表",
"option_C": "顺序有序表",
"option_D": "散列表",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "查找",
"question": "采用顺序查找方法查找长度为 n 的线性表，查找每个元素的平均比较次数为 ( )",
"option_A": "n",
"option_B": "n/2",
"option_C": "(n+1)/2",
"option_D": "(n-1)/2",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "查找",
"question": "顺序查找具有 n 个元素的线性表，其时间复杂度为 ( ) 。",
"option_A": "O (n)",
"option_B": "O (log₂n)",
"option_C": "O (n²)",
"option_D": "O (nlog₂n)",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "查找",
"question": "折半查找具有 n 个元素的线性表，其时间复杂度为 ( ) 。",
"option_A": "O (n)",
"option_B": "O (log₂n)",
"option_C": "O (n²)",
"option_D": "O (nlog₂n)",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "查找",
"question": "己知一个有序表为 (11,22,33,44,55,66,77, 88,99), 则折半查找元素 55 需要比较 ( ) 次。",
"option_A": "1",
"option_B": "2",
"option_C": "3",
"option_D": "4",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "查找",
"question": "已知一个有序表为 (11,22,33,44,55,66,77,88,99), 则顺序查找元素 55 需要比较 ( ) 次。",
"option_A": "3",
"option_B": "4",
"option_C": "5",
"option_D": "6",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "查找",
"question": "顺序查找法与二分查找法对存储结构的要求是 ( ) 。",
"option_A": "顺序查找与二分查找均只是适用于顺序表",
"option_B": "顺序查找与二分查找均既适用于顺序表，也适用于链表",
"option_C": "顺序查找只是适用于顺序表",
"option_D": "二分查找适用于顺序表",
"answer": "D",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "查找",
"question": "在对查找表的查找过程中，若被查找的数据元素不存在，则把该数据元素插到集合中。这种方式主要适合于 ( ) 。",
"option_A": "静态查找表",
"option_B": "动态查找表",
"option_C": "静态查找表与动态查找表",
"option_D": "两种表都不适合",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "查找",
"question": "若用二分查找取得的中间位置元素关键字值大于被查找值，则说明被查找值位于中间值的前面，下次的查找区间为从原开始位置至 ( ) 。",
"option_A": "该中间位置",
"option_B": "该中间位置 - 1",
"option_C": "该中间位置 + 1",
"option_D": "该中间位置 1/2",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "查找",
"question": "二叉排序树（ ）遍历序列是从小到大有序的。",
"option_A": "先序",
"option_B": "中序",
"option_C": "后序",
"option_D": "层序",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "排序",
"question": "在所有的排序方法中，关键字比较的次数与记录初始排列秩序无关的是（）。",
"option_A": "冒泡排序",
"option_B": "希尔排序",
"option_C": "直接选择排序",
"option_D": "直接插入排序",
"answer": "C",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "排序",
"question": "从未排序序列中依次取出元素与已经排好序的序列中的元素作比较，将其放入已排序序列的正确位置上，此方法称为（）。",
"option_A": "插入排序",
"option_B": "选择排序",
"option_C": "交换排序",
"option_D": "归并排序",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "排序",
"question": "从未排序序列中挑选元素，并将其放人已排序序列的一端，此方法称为（）。",
"option_A": "插入排序",
"option_B": "交换排序",
"option_C": "选择排序",
"option_D": "归并排序",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "排序",
"question": "依次将每两个相邻的有序表合并成一个有序表的排序方法称为（）。",
"option_A": "插入排序",
"option_B": "交换排序",
"option_C": "选择排序",
"option_D": "归并排序",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "排序",
"question": "当两个元素出现逆序的时候就交换位置，这种排序方法称为（）。",
"option_A": "插入排序",
"option_B": "交换排序",
"option_C": "选择排序",
"option_D": "归并排序",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "排序",
"question": "每次把待排序的区间划分为左、右两个子区间，其中左区间中的记录的关键字均小于等于基准记录的关键字，右区间中记录的关键字均大于等于基准记录的关键字，这种排序称为（）。",
"option_A": "插入排序",
"option_B": "快速排序",
"option_C": "堆排序",
"option_D": "归并排序",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "排序",
"question": "在正常情况下，直接插入排序的时间复杂度为（）。",
"option_A": "O (log₂n)",
"option_B": "O (n)",
"option_C": "O (n log₂n)",
"option_D": "O (n²)",
"answer": "D",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "排序",
"question": "在正常情况下，冒泡排序的时间复杂度为（）。",
"option_A": "O (log₂n)",
"option_B": "O (n)",
"option_C": "O (n log₂n)",
"option_D": "O (n²)",
"answer": "D",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "排序",
"question": "在归并排序中，归并趟数的数量级为（）。",
"option_A": "O (log₂n)",
"option_B": "O (n)",
"option_C": "O (n log₂n)",
"option_D": "O (n²)",
"answer": "A",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "排序",
"question": "在归并排序中，每趟需要进行的记录比较和移动次数的数量级为（）。",
"option_A": "O (log₂n)",
"option_B": "O (n)",
"option_C": "O (n log₂n)",
"option_D": "O (n²)",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "排序",
"question": "归并排序算法时间复杂度为（）。",
"option_A": "O (log₂n)",
"option_B": "O (n)",
"option_C": "O (n log₂n)",
"option_D": "O (n²)",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "排序",
"question": "平均情况下，快速排序的时间复杂度为（）。",
"option_A": "O (log₂n)",
"option_B": "O (n)",
"option_C": "O (n log₂n)",
"option_D": "O (n²)",
"answer": "C",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "排序",
"question": "最坏情况下，快速排序的时间复杂度为（）。",
"option_A": "O (log₂n)",
"option_B": "O (n)",
"option_C": "O (n log₂n)",
"option_D": "O (n²)",
"answer": "D",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "排序",
"question": "堆排序中，在每次筛运算中，记录比较和移动次数的数量级为（）。",
"option_A": "O (log₂n)",
"option_B": "O (n)",
"option_C": "O (n log₂n)",
"option_D": "O (n²)",
"answer": "A",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "排序",
"question": "堆排序算法时间复杂度为（）。",
"option_A": "O (log₂n)",
"option_B": "O (n)",
"option_C": "O (n log₂n)",
"option_D": "O (n²)",
"answer": "C",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "排序",
"question": "设有 800 条记录，希望用最快的方法挑选出其中前 10 个最大的元素，最好选用（）。",
"option_A": "插入排序",
"option_B": "快速排序",
"option_C": "堆排序",
"option_D": "归并排序",
"answer": "C",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "排序",
"question": "在待排序元素基本有序的情况下，效率最高的排序方法是（）。",
"option_A": "插入排序",
"option_B": "快速排序",
"option_C": "堆排序",
"option_D": "归并排序",
"answer": "A",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "排序",
"question": "下面几种排序方法中，要求内存量最大的是（）。",
"option_A": "插入排序",
"option_B": "交换排序",
"option_C": "选择排序",
"option_D": "归并排序",
"answer": "D",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "排序",
"question": "在下列排序方法中，关键字比较的次数与记录的初始排列秩序无关的是（）方法。",
"option_A": "希尔排序",
"option_B": "冒泡排序",
"option_C": "插入排序",
"option_D": "选择排序",
"answer": "D",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "排序",
"question": "快速排序方法在（）情况下最不利于发挥其长处。",
"option_A": "要排序的数据量太大",
"option_B": "要排序的数据中含有多个相同值",
"option_C": "要排序的数据已基本有序",
"option_D": "要排序的数据个数为奇数",
"answer": "C",
"difficulty": 6,
"bloom_level": "c"
},
{
"knowledge_point_type": "排序",
"question": "若构造一棵具有 n 个结点的二叉排序树，在最坏的情况下，其深度不会超过（）。",
"option_A": "n/2",
"option_B": "n",
"option_C": "(n＋1)/2",
"option_D": "n＋1",
"answer": "B",
"difficulty": 7,
"bloom_level": "d"
},
{
"knowledge_point_type": "排序",
"question": "考察下列排序算法的稳定性，（）是稳定的排序算法。",
"option_A": "直接插入排序、归并排序、冒泡排序",
"option_B": "简单选择排序",
"option_C": "快速排序",
"option_D": "堆排序、希尔排序",
"answer": "A",
"difficulty": 7,
"bloom_level": "d"
}
]
}