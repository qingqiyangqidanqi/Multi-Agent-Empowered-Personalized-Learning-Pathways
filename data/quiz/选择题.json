{
"data": [
{
"knowledge_point_type": "数据结构基本概念和术语",
"question": "研究数据结构就是研究 ()。",
"option_A": "数据的逻辑结构",
"option_B": "数据的存储结构",
"option_C": "数据的逻辑结构和存储结构",
"option_D": "数据的逻辑结构、存储结构及其基本操作",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "算法效率的度量",
"question": "算法分析的两个主要方面是 ()。",
"option_A": "空间复杂度和时间复杂度",
"option_B": "正确性和简单性",
"option_C": "可读性和文档性",
"option_D": "数据复杂性和程序复杂性",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "线性表的定义",
"question": "具有线性结构的数据结构是 ()。",
"option_A": "图",
"option_B": "树",
"option_C": "广义表",
"option_D": "栈",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "算法的基本概念",
"question": "计算机中的算法指的是解决某一个问题的有限运算序列，它必须具备输入、输出、() 等 5 个特性。",
"option_A": "可执行性、可移植性和可扩充性",
"option_B": "可执行性、有穷性和确定性",
"option_C": "确定性、有穷性和稳定性",
"option_D": "易读性、稳定性和确定性",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "算法效率的度量",
"question": " 下面程序段的时间复杂度是 ()。for (i=0;i<m;i++) for (j=0;j<n;j++) a [i][j]=ij;",
"option_A": "O(m²)",
"option_B": "O(n)",
"option_C": "O(mn)",
"option_D": "O (m+n)",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "算法的基本概念",
"question": "算法是 ()。",
"option_A": "计算机程序",
"option_B": "解决问题的计算方法",
"option_C": "排序算法",
"option_D": "解决问题的有限运算序列",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "算法效率的度量",
"question": "某算法的语句执行频度为 (3n²+nlog₂n+n+8), 其时间复杂度表示 ()。",
"option_A": "O (n)",
"option_B": "O (nlog₂n)",
"option_C": "O (n²)",
"option_D": "O (log₂n)",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "算法效率的度量",
"question": " 下面程序段的时间复杂度为 ()。i=1;while (i<=n) i=i3;",
"option_A": "O (n)",
"option_B": "O (3n)",
"option_C": "O (log₃n)",
"option_D": "O (n³)",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "数据结构基本概念和术语",
"question": "数据结构是一门研究非数值计算的程序设计问题中计算机的数据元素以及它们之间的 () 和运算等的学科。",
"option_A": "结构",
"option_B": "关系",
"option_C": "运算",
"option_D": "算法",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "算法效率的度量",
"question": "下面程序段的时间复杂度是 ()。while (s<n){ i=g=0; i++; s+=i; }",
"option_A": "O (n)",
"option_B": "O (n²)",
"option_C": "O (log₂n)",
"option_D": "O (n³)",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "数据结构基本概念和术语",
"question": "抽象数据类型的三个组成部分分别为 ()。",
"option_A": "数据对象、数据关系和基本操作",
"option_B": "数据元素、逻辑结构和存储结构",
"option_C": "数据项、数据元素和数据类型",
"option_D": "数据元素、数据结构和数据类型",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "算法的基本概念",
"question": "通常从正确性、易读性、健壮性、高效性等 4 个方面评价算法的质量，以下解释错误的是 ()。",
"option_A": "正确性算法应能正确地实现预定的功能",
"option_B": "易读性算法应易于阅读和理解，以便调试、修改和扩充",
"option_C": "健壮性当环境发生变化时，算法能适当地做出反应或进行处理，不会产生不需要的运行结果",
"option_D": "高效性即达到所需要的时间性能",
"answer": "D",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "算法效率的度量",
"question": " 下列程序段的时间复杂度为 ()。x=n;y=0; while (x>=(y+1)(y+1)) y=y+1;",
"option_A": "O(n)",
"option_B": "O(√n)",
"option_C": "O(1)",
"option_D": "O(n²)",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "数据结构基本概念和术语",
"question": "数据结构是一门研究非数值计算的程序设计问题中的操作对象以及它们之间的（）和运算的学科。",
"option_A": "结构",
"option_B": "关系",
"option_C": "运算",
"option_D": "算法",
"answer": "B",
"difficulty": 5,
"bloom_level": "a"
},
{
"knowledge_point_type": "数据结构基本概念和术语",
"question": "在数据结构中，从逻辑上可以把数据结构分成（）。",
"option_A": "动态结构和静态结构",
"option_B": "紧凑结构和非紧凑结构",
"option_C": "线性结构和非线性结构",
"option_D": "逻辑结构和存储结构",
"answer": "C",
"difficulty": 4,
"bloom_level": "a"
},
{
"knowledge_point_type": "线性表的定义，顺序表和链表的比较",
"question": "线性表的逻辑顺序和存储顺序总是一致的，这种说法（）。",
"option_A": "正确",
"option_B": "不正确",
"option_C": "无法确定",
"option_D": "以上答案都不对",
"answer": "B",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "算法的基本概念，算法效率的度量",
"question": "算法分析的目的是（）。",
"option_A": "找出算法的合理性",
"option_B": "研究算法的输人与输出关系",
"option_C": "分析算法的有效性以求改进",
"option_D": "分析算法的易懂性",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "算法效率的度量",
"question": "算法的时间复杂度取决于（ ）",
"option_A": "问题的规模",
"option_B": "待处理数据的初态",
"option_C": "A 和 B",
"option_D": "",
"answer": "C",
"difficulty": 4,
"bloom_level": "a"
},
{
"knowledge_point_type": "算法的基本概念",
"question": "一个算法应该是（ ）。",
"option_A": "程序",
"option_B": "问题求解步骤的描述",
"option_C": "要满足五个基本特性",
"option_D": "A 和 C",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "算法的基本概念",
"question": "下面关于算法说法错误的是（ ）",
"option_A": "算法最终必须由计算机程序实现",
"option_B": "为解决某问题的算法与为该问题编写的程序含义是相同的",
"option_C": "算法的可行性是指指令不能有二义性",
"option_D": "以上几个都是错误的",
"answer": "D",
"difficulty": 5,
"bloom_level": "b"
},
{
"knowledge_point_type": "数据结构三要素",
"question": "以下与数据的存储结构无关的术语是（ ）。",
"option_A": "循环队列",
"option_B": "链表",
"option_C": "哈希表",
"option_D": "栈",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "算法效率的度量",
"question": "在下面的程序段中，对 x 的赋值语句的频度为（ ）\nfor（i=0;i<n;i++）\n for (j=0;j<n;j++) \n x=x+1;",
"option_A": "2n",
"option_B": "n",
"option_C": "n²",
"option_D": "log2n",
"answer": "C",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "数据结构基本概念和术语",
"question": "以下数据结构中，（ ）是非线性数据结构",
"option_A": "树",
"option_B": "字符串",
"option_C": "队列",
"option_D": "栈",
"answer": "A",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "数据结构基本概念和术语",
"question": "下列数据中，（ ）是线性数据结构。",
"option_A": "哈夫曼树",
"option_B": "有向无环图",
"option_C": "二叉排序树",
"option_D": "栈",
"answer": "D",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "数据结构三要素",
"question": "以下属于逻辑结构的是（ ）。",
"option_A": "顺序表",
"option_B": "哈希表",
"option_C": "有序表",
"option_D": "单链表",
"answer": "C",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表的基本操作，顺序表的定义",
"question": "若长度为 n 的线性表采用顺序存储结构，在其第 i 个位置插入一个新元素算法的时间复杂度 ()。",
"option_A": "O (log₂n)",
"option_B": "O (1)",
"option_C": "O (n)",
"option_D": "O (n²)",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表的基本操作，顺序表和链表的比较",
"question": "若一个线性表中最常用的操作是取第 i 个元素和找第 i 个元素的前趋元素，则采用 () 存储方式最节省时间。",
"option_A": "顺序表",
"option_B": "单链表",
"option_C": "双链表",
"option_D": "单循环链表",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表的定义",
"question": "具有线性结构的数据结构是 ()。",
"option_A": "图",
"option_B": "树",
"option_C": "广义表",
"option_D": "栈",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "线性表的基本操作",
"question": "在一个长度为 n 的顺序表中，在第 i 个元素之前插入一个新元素时，需向后移动 () 个元素。",
"option_A": "n-i",
"option_B": "n-i+1",
"option_C": "n-i-1",
"option_D": "i",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "循环链表",
"question": "非空的循环单链表 head 的尾结点 p 满足 ()。",
"option_A": "p->next==head",
"option_B": "p->next==NULL",
"option_C": "p= NULL",
"option_D": "p==head",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "链表的存储结构",
"question": "链表不具有的特点是 ()。",
"option_A": "可随机访问任一元素",
"option_B": "插入删除不需要移动元素",
"option_C": "不必事先估计存储空间",
"option_D": "所需空间与线性表长度成正比",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "双链表",
"question": "在双向循环链表中，在 p 指针所指的结点后插入一个指针 q 所指向的新结点，修改指针的操作是 ()。",
"option_A": "p->next=q;q->prior=p;p->next->prior=q;q->next=q;",
"option_B": "p->next=q;p->next->prior=q;q->prior=p;q->next=p->next;",
"option_C": "q->prior=p;q->next=p->next;p->next->prior=q;p->next=q;",
"option_D": "q->next=p->next;q->prior=p;p->next=q;p->next=q;",
"answer": "C",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "链表的存储结构",
"question": "线性表采用链式存储时，结点的存储地址 ()。",
"option_A": "必须是连续的",
"option_B": "必须是不连续的",
"option_C": "连续与否均可",
"option_D": "和头结点的存储地址相连续",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "线性表的基本操作",
"question": "在一个长度为 n 的顺序表中删除第 i 个元素，需要向前移动 () 个元素。",
"option_A": "n-i",
"option_B": "n-i+1",
"option_C": "n-i-1",
"option_D": "i+1",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表的定义",
"question": "线性表是 n 个 () 的有限序列。",
"option_A": "表元素",
"option_B": "字符",
"option_C": "数据元素",
"option_D": "数据项",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "循环链表",
"question": "从表中任一结点出发，都能扫描整个表的是 ()。",
"option_A": "单链表",
"option_B": "顺序表",
"option_C": "循环链表",
"option_D": "静态链表",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "单链表上基本操作的实现",
"question": "在具有 n 个结点的单链表上查找值为 x 的元素时，其时间复杂度为 ()。",
"option_A": "O (n)",
"option_B": "O (1)",
"option_C": "O (n²)",
"option_D": "O (n-1)",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "线性表的定义",
"question": " 线性表 L=(a1,a2,...,an), 下列说法正确的是 ()。",
"option_A": "每个元素都有一个直接前驱和一个直接后继",
"option_B": "线性表中至少要有一个元素",
"option_C": "表中诸元素的排列顺序必须是由小到大或由大到小",
"option_D": "除第一个和最后一个元素外，其余每个元素都有一个且仅有一个直接前驱和直接后继",
"answer": "D",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "顺序表的定义",
"question": "一个顺序表的第一个元素的存储地址是 90, 每个元素的长度为 2, 则第 6 个元素的存储地址是 ()。",
"option_A": "98",
"option_B": "100",
"option_C": "102",
"option_D": "106",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "顺序表和链表的比较",
"question": "在线性表的下列存储结构中，读取元素花费的时间最少的是 ()。",
"option_A": "单链表",
"option_B": "双链表",
"option_C": "循环链表",
"option_D": "顺序表",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "单链表上基本操作的实现",
"question": "在一个单链表中，若删除 p 所指向结点的后续结点，则执行 ()。",
"option_A": "p->next=p->next->next;",
"option_B": "p=p->next;p->next=p->next->next;",
"option_C": "p=p->next;",
"option_D": "p=p->next->next;",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "单链表上基本操作的实现",
"question": "将长度为 n 的单链表连接在长度为 m 的单链表之后的算法的时间复杂度为 ()。",
"option_A": "O (1)",
"option_B": "O (n)",
"option_C": "O (m)",
"option_D": "O (m+n)",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "顺序表的定义",
"question": "线性表的顺序存储结构是一种 () 存储结构。",
"option_A": "随机存取",
"option_B": "顺序存取",
"option_C": "索引存取",
"option_D": "散列存取",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "顺序表的基本操作",
"question": "顺序表中，插入一个元素所需移动的元素平均数是 ()。",
"option_A": "(n-1)/2",
"option_B": "n",
"option_C": "n+1",
"option_D": "(n+1)/2",
"answer": "A",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "循环链表",
"question": "循环链表的主要优点是 ()。",
"option_A": "不再需要头指针",
"option_B": "已知某结点位置后能容易找到其直接前驱",
"option_C": "在进行插入、删除运算时能保证链表不断开",
"option_D": "在表中任一结点出发都能扫描整个链表",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "单链表的定义",
"question": "不带头结点的单链表 head 为空的判定条件是 ()。",
"option_A": "head=NULL",
"option_B": "head->next==NULL",
"option_C": "head->next==head",
"option_D": "head!=NULL",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "顺序表的基本操作",
"question": "在下列对顺序表进行的操作中，算法时间复杂度为 O (1) 的是 ()。",
"option_A": "访问第 i 个元素的前驱 (1<i≤n)",
"option_B": "在第 i 个元素之后插入一个新元素 (1≤i<n)",
"option_C": "删除第 i 个元素 (1≤i≤n)",
"option_D": "对顺序表中元素进行排序",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "单链表上基本操作的实现",
"question": "已知指针 p 和 q 分别指向某单链表中第一个结点和最后一个结点。假设指针 s 指向另一个单链表中某个结点，则在 s 所指结点之后插入上述链表应执行的语句为 ()。",
"option_A": "q->next=s->next;s->next=p;",
"option_B": "s->next=p;q->next=s->next;",
"option_C": "p->next=s->next;s->next=q;",
"option_D": "s->next=q;p->next=s->next;",
"answer": "A",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "顺序表和链表的比较",
"question": "在以下的叙述中，正确的是 ()。",
"option_A": "线性表的顺序存储结构优于链表存储结构",
"option_B": "线性表的顺序存储结构适用于频繁插入 / 删除数据元素的情况",
"option_C": "线性表的链表存储结构适用于频繁插入 / 删除数据元素的情况",
"option_D": "线性表的链表存储结构优于顺序存储结构",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "顺序表的基本操作",
"question": "在表长为 n 的顺序表中，当在任何位置删除一个元素的概率相同时，删除一个元素所需移动的平均个数为 ()。",
"option_A": "(n-1)/2",
"option_B": "n/2",
"option_C": "(n+1)/2",
"option_D": "n",
"answer": "A",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "单链表上基本操作的实现",
"question": "在一个单链表中，已知 q 所指结点是 p 所指结点的前驱结点，若在 q 和 p 之间插入一个结点 s, 则执行 ()。",
"option_A": "s->next=p->next;p->next=s;",
"option_B": "p->next=q->next;s->next=p;",
"option_C": "q->next=s;s->next=p;",
"option_D": "p->next=s;s->next=q;",
"answer": "C",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "单链表上基本操作的实现",
"question": "在单链表中，指针 p 指向元素为 x 的结点，实现删除 x 的后继的语句是 ()。",
"option_A": "p=p->next;",
"option_B": "p->next=p->next->next;",
"option_C": "p->next=p;",
"option_D": "p=p->next->next;",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "循环链表",
"question": "在头指针为 head 且表长大于 1 的单循环链表中，指针 p 指向表中某个结点，若 p->next->next==head, 则 ()。",
"option_A": "p 指向头结点",
"option_B": "p 指向尾结点",
"option_C": "p 的直接后继是头结点",
"option_D": "p 的直接后继是尾结点",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "顺序表上基本操作的实现",
"question": "在一个长度为 n 的顺序表中删除第 i 个元素（0<i<=n）时，需要向前移动 ( ) 个元素。",
"option_A": "n-i",
"option_B": "n-i+1",
"option_C": "n-i-1",
"option_D": "i+1",
"answer": "A",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "线性表的基本操作",
"question": "从一个具有 n 个元素的线性表中查找其值等于 x 的结点时，在查找成功的情况下，需平均比较 ( ) 个元素结点。",
"option_A": "n/2",
"option_B": "n",
"option_C": "(n-1)/2",
"option_D": "(n +1)/2",
"answer": "D",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "单链表上基本操作的实现",
"question": "对一个具有 n 个元素的线性表，建立其单链表的时间复杂度为 ( )。",
"option_A": "O (n)",
"option_B": "O (1)",
"option_C": "O (n²）",
"option_D": "O（long2n）",
"answer": "A",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "单链表的定义",
"question": "线性表采用链式存储时，其地址 ( )。",
"option_A": "必须是连续的",
"option_B": "一定是不连续的",
"option_C": "部分地址必须连续",
"option_D": "连续与否均可以",
"answer": "D",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "单链表上基本操作的实现",
"question": "在一个具有 n 个结点的有序单链表中插人一个新的结点，使得链表仍然有序，该算法的时间复杂度是 ( )。",
"option_A": "O（long2n）",
"option_B": "O（l）",
"option_C": "O（n²）",
"option_D": "O（n）",
"answer": "D",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表的定义",
"question": "线性表是 ( )。",
"option_A": "一个有限序列，可以为空",
"option_B": "一个有限序列，不可以为空",
"option_C": "一个无限序列，可以为空",
"option_D": "一个无限序列，不可以为空",
"answer": "A",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "顺序表上基本操作的实现",
"question": "在一个长度为 n 的顺序表中，向第 i 个位置（0 一 1＜n＋1）插入一个新元素时，需要向后移动 ( ) 个元素。",
"option_A": "n-i",
"option_B": "n-i＋1",
"option_C": "n－i－1",
"option_D": "i＋1",
"answer": "B",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "顺序表和链表的比较",
"question": "如果某链表中最常用的操作是取第 i 个结点及其前驱，则采用 ( ) 存储方式最节省时间。",
"option_A": "单链表",
"option_B": "双向链表",
"option_C": "单循环链表",
"option_D": "顺序表",
"answer": "D",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "顺序表的存储结构",
"question": "一个顺序存储线性表的第一个元素的存储地址是 90，每个元素的长度是 2，则第 6 个元素的存储地址是（）。",
"option_A": "98",
"option_B": "100",
"option_C": "102",
"option_D": "106",
"answer": "B",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "顺序表上基本操作的实现",
"question": "在顺序存储的线性表（a1……an）中，删除任意一个结点所需移动结点的平均移动次数为 ( )",
"option_A": "n",
"option_B": "n／2",
"option_C": "(n-1)/2",
"option_D": "（n＋l）/2",
"answer": "C",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "顺序表的定义",
"question": "在线性表的下列存储结构中，读取第 i 个元素花费的时间最少的是（）。",
"option_A": "单链表",
"option_B": "双链表",
"option_C": "循环链表",
"option_D": "顺序表",
"answer": "D",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "双链表，循环链表",
"question": "若某链表中最常用的操作为在最后一个结点之后插入一个结点和删除最后一个结点，则采用（）存储方式最节省时间。",
"option_A": "双链表",
"option_B": "单链表",
"option_C": "单循环链表",
"option_D": "带头结点的双循环链表",
"answer": "D",
"difficulty": 4,
"bloom_level": "c"
},
{
"knowledge_point_type": "单链表上基本操作的实现",
"question": "在单链表中删除指针 p 所指结点的后继结点，则执行（ ）操作。",
"option_A": "p->next=p->next->next",
"option_B": "p->next=p->next",
"option_C": "p=p->next->next",
"option_D": "p=p->next; p->next=p->next->next",
"answer": "A",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "单链表上基本操作的实现",
"question": "在一个单链表中，已知 q 所指结点是 p 所指结点的前驱，若在 q 和 p 之间插入 s 所指的结点，则执行（ ）操作。",
"option_A": "s->next=p->next; p->next=s",
"option_B": "q->next=s; s->next=p",
"option_C": "p->next=s->next; s->next=p",
"option_D": "p->next=s; s->next=q",
"answer": "B",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "单链表的定义",
"question": "在单链表中附加头结点的目的是为了（ ）。",
"option_A": "保证单链表中至少有一个节点",
"option_B": "标识单链表中首结点的位置",
"option_C": "方便运算的实现",
"option_D": "说明单链表是线性表的链式存储",
"answer": "C",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "循环链表",
"question": "循环单链表的主要优点是（ ）。",
"option_A": "不再需要头指针了",
"option_B": "从表中任意一个结点出发都能扫描到整个链表",
"option_C": "已知某个结点的位置后，能够容易找到它的前驱",
"option_D": "在进行插入、删除操作时，能更好地保证链表不断开",
"answer": "B",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "循环链表",
"question": "非空的循环单链表 L 的尾结点 p 满足（ ）。",
"option_A": "p->next=NULL",
"option_B": "p=NULL",
"option_C": "p->next=L",
"option_D": "p=L",
"answer": "C",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "双链表",
"question": "在双向循环链表中，在 p 指针所指向的结点前插入一个指针 q 所指向的新结点，其修改指针的操作是 ( )。注：双向链表的结点结构为 (prior,data,next)。",
"option_A": "p->prior=q； q->next=p； p->prior->next=q； q->prior=q；",
"option_B": "p->prior=q； p->prior->next=q; q->next=p； q->prior=p->prior；",
"option_C": "q->next=p； q->prior=p->prior；p->prior->next=q; p->prior=q;",
"option_D": "q->prior=p->prior； q->next=p； p->prior=q； p->prior=q；",
"answer": "C",
"difficulty": 4,
"bloom_level": "c"
},
{
"knowledge_point_type": "双链表",
"question": "在双向链表存储结构中，删除 p 所指的结点时须修改指针（ ）。",
"option_A": "p->prior->next=p->next; p->next->prior=p->prior",
"option_B": "p->prior=p->prior->prior; p->prior->next=p;(删 p 的前趋)",
"option_C": "p->next->prior=p; p->next=p->next->next",
"option_D": "p->next= p->prior->prior; p->prior= p->next->next",
"answer": "A",
"difficulty": 4,
"bloom_level": "c"
},
{
"knowledge_point_type": "栈的基本概念",
"question": "一个栈的输入序列为:a,b,c,d,e, 则栈的不可能输出的序列是 ()。",
"option_A": "a,b,c,d,e",
"option_B": "d,e,c,b,a",
"option_C": "d,c,e,a,b",
"option_D": "e,d,c,b,a",
"answer": "C",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "队列的顺序存储结构",
"question": "判断一个循环队列 Q (最多 n 个元素) 为满的条件是 ()。",
"option_A": "Q->rear==Q->front",
"option_B": "Q->rear==Q->front+1",
"option_C": "Q->front==(Q->rear+1)% n",
"option_D": "Q->front==(Q->rear-1)% n",
"answer": "C",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "栈在括号匹配中的应用",
"question": "设计一个判别表达式中括号是否配对的算法，采用 () 数据结构最佳。",
"option_A": "顺序表",
"option_B": "链表",
"option_C": "队列",
"option_D": "栈",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "单链表的定义",
"question": "带头结点的单链表 head 为空的判定条件是 ()。",
"option_A": "head==NULL",
"option_B": "head->next==NULL",
"option_C": "head->next!=NULL",
"option_D": "head!=NULL",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈的基本概念",
"question": "一个栈的输入序列为：1,2,3,4, 则栈的不可能输出的序列是 ()。",
"option_A": "1243",
"option_B": "2134",
"option_C": "1432",
"option_D": "4312",
"answer": "D",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "队列的顺序存储结构",
"question": "若用一个大小为 6 的数组来实现循环队列，且当 rear 和 front 的值分别为 0,3。当从队列中删除一个元素，再加入两个元素后，rear 和 front 的值分别为 ()。",
"option_A": "1 和 5",
"option_B": "2 和 4",
"option_C": "4 和 2",
"option_D": "5 和 1",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "队列的基本概念",
"question": "队列的插入操作是在 ()。",
"option_A": "队尾",
"option_B": "队头",
"option_C": "队列任意位置",
"option_D": "队头元素后",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "队列的顺序存储结构",
"question": "循环队列的队头和队尾指针分别为 front 和 rear, 则判断循环队列为空的条件是 ()。",
"option_A": "front==rear",
"option_B": "front==0",
"option_C": "rear==0",
"option_D": "front=rear+1",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈的顺序存储结构",
"question": "一个顺序栈 s, 其栈顶指针为 top, 则将元素 e 入栈的操作是 ()。",
"option_A": "*s->top=e;s->top++;",
"option_B": "S->top++;*S->top=e;",
"option_C": "S->top=e",
"option_D": "S->top=e;",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "栈在表达式求值中的应用",
"question": " 表达式 a(b+c)-d 的后缀表达式是 ()。",
"option_A": "abcd+",
"option_B": "abc+d-",
"option_C": "abc+d",
"option_D": "-+*abcd",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "栈在递归中的应用",
"question": "将递归算法转换成对应的非递归算法时，通常需要使用 () 来保存中间结果。",
"option_A": "队列",
"option_B": "栈",
"option_C": "链表",
"option_D": "树",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈的基本概念",
"question": "栈的插入和删除操作在 ()。",
"option_A": "栈底",
"option_B": "栈顶",
"option_C": "任意位置",
"option_D": "指定位置",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈的基本概念",
"question": "五节车厢以编号 1,2,3,4,5 顺序进入铁路调度站 (栈), 可以得到 () 的编组。",
"option_A": "3,4,5,1,2",
"option_B": "2,4,1,3,5",
"option_C": "3,5,4,2,1",
"option_D": "1,3,5,2,4",
"answer": "C",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "栈的顺序存储结构",
"question": "判定一个顺序栈 s (栈空间大小为 n) 为空的条件是 ()。",
"option_A": "S->top==0",
"option_B": "S->top!=0",
"option_C": "S->top==n",
"option_D": "S->top!=n",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "队列的链式存储结构",
"question": "在一个链队列中，front 和 rear 分别为头指针和尾指针，则插入一个结点 s 的操作为 ()。",
"option_A": "front=front->next",
"option_B": "s->next=rear;rear=s;",
"option_C": "rear->next=s; rear=s;",
"option_D": "s->next=front;front=s;",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "队列的基本概念",
"question": "一个队列的入队序列是 1,2,3,4, 则队列的出队序列是 ()。",
"option_A": "1,2,3,4",
"option_B": "4,3,2,1",
"option_C": "1,4,3,2",
"option_D": "3,4,1,2",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "队列的基本概念",
"question": "依次在初始为空的队列中插入元素 a,b,c,d 以后，紧接着做了两次删除操作，此时的队头元素是 ()。",
"option_A": "a",
"option_B": "b",
"option_C": "c",
"option_D": "d",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈的顺序存储结构",
"question": "正常情况下，删除非空的顺序存储结构的堆栈的栈顶元素，栈顶指针 top 的变化是 ()。",
"option_A": "top 不变",
"option_B": "top=0",
"option_C": "top=top+1",
"option_D": "top=top-1",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "队列的顺序存储结构",
"question": "判断一个循环队列 Q (空间大小为 M) 为空的条件是 ()。",
"option_A": "Q->front==Q->rear",
"option_B": "Q->rear-Q->front-1==M",
"option_C": "Q->front+1=Q->rear",
"option_D": "Q->rear+1=Q->front",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈在括号匹配中的应用",
"question": "设计一个判别表达式中左右括号是否配对出现的算法，采用 () 数据结构最佳。",
"option_A": "线性表的顺序存储结构",
"option_B": "队列",
"option_C": "栈",
"option_D": "线性表的链式存储结构",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "队列的顺序存储结构",
"question": "当用大小为 N 的数组存储顺序循环队列时，该队列的最大长度为 ()。",
"option_A": "N",
"option_B": "N+1",
"option_C": "N-1",
"option_D": "N-2",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "队列的基本概念",
"question": "队列的删除操作是在 ()。",
"option_A": "队首",
"option_B": "队尾",
"option_C": "队前",
"option_D": "队后",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈的基本概念",
"question": "若让元素 1,2,3 依次进栈，则出栈次序不可能是 ()。",
"option_A": "3,2,1",
"option_B": "2,1,3",
"option_C": "3,1,2",
"option_D": "1,3,2",
"answer": "C",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "队列的顺序存储结构",
"question": "循环队列用数组 A [0,m-1] 存放其元素值，已知其头尾指针分别是 front 和 rear, 则当前队列中的元素个数是 ()。",
"option_A": "(rear-front+m)% m",
"option_B": "rear-front+1",
"option_C": "rear-front-1",
"option_D": "rear-front",
"answer": "A",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "队列在计算机系统中的应用",
"question": "在解决计算机主机和打印机之间速度不匹配问题时，通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则从该缓冲区中取走数据打印。该缓冲区应该是一个 () 结构。",
"option_A": "堆栈",
"option_B": "队列",
"option_C": "数组",
"option_D": "线性表",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈和队列的基本概念",
"question": "栈和队列都是 ()。",
"option_A": "链式存储的线性结构",
"option_B": "链式存储的非线性结构",
"option_C": "限制存取点的线性结构",
"option_D": "限制存取点的非线性结构",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "队列的链式存储结构",
"question": "在一个链队列中，假定 front 和 rear 分别为队头指针和队尾指针，删除一个结点的操作是 ()。",
"option_A": "front=front->next",
"option_B": "rear= rear->next",
"option_C": "rear->next=front",
"option_D": "front->next=rear",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "栈和队列的基本概念",
"question": "栈和队列的主要区别是 ()。",
"option_A": "逻辑结构不同",
"option_B": "存储结构不同",
"option_C": "所包含的运算个数不同",
"option_D": "限定插入和删除的位置不同",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈的基本概念",
"question": "一个栈的序列是：a，b，c，d，e，则栈的不可能输出的序列是（）。",
"option_A": "a，b，c，d，e",
"option_B": "d，e，c，b，a",
"option_C": "d，c，e，a，b",
"option_D": "e，d，c，b，a",
"answer": "C",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "栈的基本概念",
"question": "若一个栈的输人序列是 1，2，3，…，n，输出序列的第一个元素是 n，则第 k 个输出元素是（ ）。",
"option_A": "k",
"option_B": "n-k-1",
"option_C": "n-k+1",
"option_D": "不确定",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "栈的顺序存储结构",
"question": "判定一个栈 S（最多有 n 个元素）为空的条件是（ ）。",
"option_A": "S->top！＝0",
"option_B": "S->top= =0",
"option_C": "S->top!=n",
"option_D": "S->top= =n",
"answer": "B",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈的顺序存储结构",
"question": "判定一个栈 S（最多有 n 个元素）为满的条件是（ ）。",
"option_A": "S->top!=0",
"option_B": "S->top= =0",
"option_C": "S->top!=n",
"option_D": "S->top= =n",
"answer": "D",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈的链式存储结构",
"question": " 向一个栈顶指针为 top 的不带头结点的链栈中插人一个S 结点的时候，应当执行语句（ ）。",
"option_A": "top->next=S",
"option_B": "S->next=top；top=S",
"option_C": "S->next＝top->next；top->next＝S",
"option_D": "S->next＝top；top＝S->next",
"answer": "B",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "栈的链式存储结构",
"question": " 向一个带头结点、栈顶指针为 top 的链栈中插人一个S 结点的时候，应当执行语句（ ）。",
"option_A": "top->next=S",
"option_B": "S->next=top；top=S",
"option_C": "S->next=top->next；top->next=S",
"option_D": "S->next=top；top=S->next",
"answer": "C",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "队列的顺序存储结构",
"question": "判定一个队列 Q（最多有 n 个元素）为空的条件是（ ）。",
"option_A": "Q->rear-Q->front= =n",
"option_B": "Q->rear-Q->front+1= =n",
"option_C": "Q->rear = = Q->front",
"option_D": "Q->rear +1= = Q->front",
"answer": "C",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "队列的顺序存储结构",
"question": "判定一个队列 Q（最多有 n 个元素）为满的条件是（）。",
"option_A": "Q->rear-Q->front= =n",
"option_B": "Q->rear-Q->front+1= =n",
"option_C": "Q->rear = = Q->front",
"option_D": "Q->rear +1= = Q->front",
"answer": "A",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "循环队列",
"question": "判定一个循环队列 Q（最多有 n 个元素）为空的条件是（ ）。",
"option_A": "Q->rear = = Q->front",
"option_B": "Q->rear = = Q->front＋l",
"option_C": "Q->front= =(Q->rear +1)％n",
"option_D": "Q->front= =(Q->rear -1)％n",
"answer": "A",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "循环队列",
"question": "判定一个循环队列 Q（最多有 n 个元素）为满的条件是（ ）。",
"option_A": "Q->rear = = Q->front",
"option_B": "Q->rear = = Q->front＋l",
"option_C": "Q->front= =(Q->rear +1)％n",
"option_D": "Q->front= =(Q->rear -1)％n",
"answer": "C",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "队列的链式存储结构",
"question": "在一个链队列中，假定 front 和 rear 分别为头指针和尾指针，则插入一个结点 * S 的操作是（ ）。",
"option_A": "front＝front->next",
"option_B": "S->next=rear；rear=S",
"option_C": "rear->next=S；rear=S",
"option_D": "S->next=front；front＝S",
"answer": "C",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "队列的链式存储结构",
"question": "在一个链队列中，假定 front 和 rear 分别为头指针和尾指针，删除一个结点的操作是（ ）。",
"option_A": "front=front->next",
"option_B": "rear=rear->next",
"option_C": "rear->next=front",
"option_D": "front->next＝rear",
"answer": "A",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈的基本概念，队列的基本概念",
"question": "栈与队列都是（ ）。",
"option_A": "链式存储的线性结构",
"option_B": "链式存储的非线性结构",
"option_C": "限制存取点的线性结构",
"option_D": "限制存取点的非线性结构",
"answer": "C",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈的基本概念",
"question": "若进栈序列为 l，2，3，4，则（ ）不可能是一个出栈序列。",
"option_A": "3，2，4，1",
"option_B": "l，2，3，4",
"option_C": "4，2，3，1",
"option_D": "4，3，2，l",
"answer": "C",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "队列的应用",
"question": "在解决计算机主机与打印机之间速度不匹配问题时通常设置一个打印数据缓冲区，主机将要输出的数据依次写人该缓冲区，而打印机则从该缓冲区中取走数据打印。该缓冲区应该是一个（ ）结构。",
"option_A": "堆栈",
"option_B": "队列",
"option_C": "数组",
"option_D": "线性表",
"answer": "B",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "串的模式匹配算法 ——KMP 算法",
"question": "设有两个串 s1 和 s2, 求串 s2 在 s1 中首次出现位置的运算称作 ()。",
"option_A": "连接",
"option_B": "求子串",
"option_C": "模式匹配",
"option_D": "判断子串",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "串的模式匹配算法 ——KMP 算法",
"question": "已知串 S=aaab, 则 next 数组值为 ()。",
"option_A": "0123",
"option_B": "1123",
"option_C": "1231",
"option_D": "1211",
"answer": "A",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "串的定义",
"question": "串与普通的线性表相比较，它的特殊性体现在 ()。",
"option_A": "顺序的存储结构",
"option_B": "链式存储结构",
"option_C": "数据元素是一个字符",
"option_D": "数据元素任意",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "串的模式匹配算法 ——KMP 算法",
"question": "设串长为 n, 模式串长为 m, 则 KMP 算法所需的附加空间为 ()。",
"option_A": "O (m)",
"option_B": "O (n)",
"option_C": "O (m*n)",
"option_D": "O (nlog₂m)",
"answer": "A",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "串的定义",
"question": "空串和空格串 ()。",
"option_A": "相同",
"option_B": "不相同",
"option_C": "可能相同",
"option_D": "无法确定",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "串的基本操作",
"question": "与线性表相比，串的插入和删除操作的特点是 ()。",
"option_A": "通常以串整体作为操作对象",
"option_B": "需要更多的辅助空间",
"option_C": "算法的时间复杂度较高",
"option_D": "涉及移动的元素更多",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "串的基本操作",
"question": "设 SUBSTR (S,i,k) 是求 s 中从第 i 个字符开始的连续 k 个字符组成的子串的操作，则对于 s=Beijing&NanjingSUBSTR (S,4,5)=()。",
"option_A": "ijing",
"option_B": "jing&",
"option_C": "ingNa",
"option_D": "ing&N",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "广义表的定义",
"question": "设广义表 L=((a,b,c)), 则 L 的长度和深度分别为 ()。",
"option_A": "1 和 1",
"option_B": "1 和 3",
"option_C": "1 和 2",
"option_D": "2 和 3",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "广义表的定义",
"question": "广义表 ((a),a) 的表尾是 ()。",
"option_A": "a",
"option_B": "(a)",
"option_C": "()",
"option_D": "((a))",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "稀疏矩阵的压缩存储",
"question": "稀疏矩阵的常见压缩存储方法有 () 两种。",
"option_A": "二维数组和三维数组",
"option_B": "三元组和散列表",
"option_C": "三元组和十字链表",
"option_D": "散列表和十字链表",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "广义表的定义",
"question": "一个非空广义表的表头 ()。",
"option_A": "不可能是子表",
"option_B": "只能是子表",
"option_C": "只能是原子",
"option_D": "可以是子表或原子",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "数组的存储结构",
"question": "数组 A [0..5,0..6] 的每个元素占 5 个字节，将其按列优先次序存储在起始地址为 1000 的内存单元中，则元素 A [5][5] 的地址是 ()。",
"option_A": "1175",
"option_B": "1180",
"option_C": "1205",
"option_D": "1210",
"answer": "A",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "广义表的定义",
"question": "广义表 G=(a,b,(c,d,(e,f),g) 的长度是 ()。",
"option_A": "3",
"option_B": "4",
"option_C": "7",
"option_D": "8",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "稀疏矩阵的压缩存储",
"question": "采用稀疏矩阵的三元组表形式进行压缩存储，若要完成对三元组表进行转置，只要将行和列对换，这种说法 ()。",
"option_A": "正确",
"option_B": "错误",
"option_C": "无法确定",
"option_D": "以上均不对",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "广义表的定义",
"question": "广义表 (a,b,c) 的表尾是 ()。",
"option_A": "b,c",
"option_B": "(b,c)",
"option_C": "c",
"option_D": "(c)",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "数组的定义",
"question": "常对数组进行两种基本操作是 ()。",
"option_A": "建立和删除",
"option_B": "索引和修改",
"option_C": "查找和修改",
"option_D": "查找与索引",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "特殊矩阵的压缩存储",
"question": "对一些特殊矩阵采用压缩存储的目的主要是为了 ()。",
"option_A": "表达变得简单",
"option_B": "对矩阵元素的存取变得简单",
"option_C": "去掉矩阵中的多余元素",
"option_D": "减少不必要的存储空间的开销",
"answer": "D",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "特殊矩阵的压缩存储",
"question": "设有一个 10 阶的对称矩阵 A, 采用压缩存储方式，以行序为主存储，a11 为第一个元素，其存储地址为 1, 每元素占 1 个地址空间，则 a85 的地址为 ()。",
"option_A": "13",
"option_B": "33",
"option_C": "18",
"option_D": "40",
"answer": "B",
"difficulty": 6,
"bloom_level": "d"
},
{
"knowledge_point_type": "特殊矩阵的压缩存储",
"question": "设矩阵 A 是一个对称矩阵，为了节省存储，将其下三角部分按行序存放在一维数组 B [1..n (n-1)/2] 中，对下三角部分中任一元素 ai,j (i≥j), 在一维数组 B 的下标位置 k 的值是 ()。",
"option_A": "i (i-1)/2+j-1",
"option_B": "i (i-1)/2+j",
"option_C": "i (i+1)/2+j-1",
"option_D": "i (i+1)/2+j",
"answer": "B",
"difficulty": 6,
"bloom_level": "d"
},
{
"knowledge_point_type": "广义表的定义",
"question": "广义表 A=((a),a) 的表头是 ()。",
"option_A": "a",
"option_B": "(a)",
"option_C": "b",
"option_D": "((a))",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "稀疏矩阵的压缩存储",
"question": "稀疏矩阵一般的压缩存储方法有两种，即 ()。",
"option_A": "二维数组和三维数组",
"option_B": "三元组和散列",
"option_C": "三元组和十字链表",
"option_D": "散列和十字链表",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "串的定义",
"question": "空串与空格串（ ）。",
"option_A": "相同",
"option_B": "不相同",
"option_C": "可能相同",
"option_D": "无法确定",
"answer": "B",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "串的模式匹配算法",
"question": "设有两个申 S1 与 S2，求串 S2 在 S1 中首次出现位置的运算称作（ ）。",
"option_A": "连接",
"option_B": "求子串",
"option_C": "模式匹配",
"option_D": "判子串",
"answer": "C",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "串的定义",
"question": "串与普通的线性表相比较，它的特殊性体现在（ ）。",
"option_A": "顺序的存储结构",
"option_B": "链接的存储结构",
"option_C": "数据元素是一个字符",
"option_D": "数据元素可以任意",
"answer": "C",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "串的基本操作",
"question": "设有串 S=‘Computer’，则其子串的数目是（ ）。",
"option_A": "36",
"option_B": "37",
"option_C": "8",
"option_D": "9",
"answer": "A",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "数组的定义",
"question": "数组常用的两种基本操作是（ ）。",
"option_A": "建立与查找",
"option_B": "删除与查找",
"option_C": "插人与索引",
"option_D": "查找与修改",
"answer": "D",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "稀疏矩阵",
"question": "对稀疏矩阵进行压缩存储，常用的两种方法是（ ）。",
"option_A": "二元组和散列表",
"option_B": "三元组表和十字链表",
"option_C": "三角矩阵和对角矩阵",
"option_D": "对角矩阵和十字链表",
"answer": "B",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "稀疏矩阵",
"question": "采用稀疏矩阵的三元组表形式进行压缩存储，若要完对三元组表进行成转置，只要将行和列对换，这种说法（ ）。",
"option_A": "正确",
"option_B": "错误",
"option_C": "无法确定",
"option_D": "以上均不对",
"answer": "B",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "广义表的概念",
"question": "一个广义表的表头总是一个广义表，这种说法（ ）。",
"option_A": "正确",
"option_B": "错误",
"option_C": "无法确定",
"option_D": "以上均不对",
"answer": "B",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "广义表的概念",
"question": "一个广义表的表尾总是一个广义表，这种说法（ ）。",
"option_A": "正确",
"option_B": "错误",
"option_C": "无法确定",
"option_D": "以上均不对",
"answer": "A",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "广义表的表头表尾",
"question": "广义表 ((a)) 的表头是（ ）。",
"option_A": "（ ）",
"option_B": "a",
"option_C": "（a）",
"option_D": "（（a））",
"answer": "C",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "广义表的表头表尾",
"question": "广义表（（a））的表尾是（ ）。",
"option_A": "（）",
"option_B": "a",
"option_C": "（a）",
"option_D": "（（a））",
"answer": "A",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "广义表的表头表尾",
"question": "广义表（（a），a）的表头是（ ）。",
"option_A": "（ ）",
"option_B": "a",
"option_C": "（a）",
"option_D": "（（a））",
"answer": "C",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "广义表的表头表尾",
"question": "广义表（（a），a）的表尾是（ ）。",
"option_A": "( )",
"option_B": "a",
"option_C": "（a）",
"option_D": "（（a））",
"answer": "C",
"difficulty": 4,
"bloom_level": "c"
},
{
"knowledge_point_type": "广义表的表头表尾",
"question": "广义表（a，b，c）的表头是（ ）。",
"option_A": "a",
"option_B": "（a）",
"option_C": "a，b",
"option_D": "（b，c）",
"answer": "A",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "广义表的表头表尾",
"question": "广义表（a，b，c）的表尾是（ ）。",
"option_A": "b，c",
"option_B": "（b，c）",
"option_C": "a．b，c",
"option_D": "（a，b，c）",
"answer": "B",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "广义表的操作",
"question": "广义表 A 满足 Head（）= Tail（），则 A 为（）。",
"option_A": "（）",
"option_B": "（（））",
"option_C": "（（），（））",
"option_D": "（（），（），（））",
"answer": "B",
"difficulty": 5,
"bloom_level": "d"
},
{
"knowledge_point_type": "二叉树的定义及其主要特性",
"question": "二叉树的深度为 k, 则二叉树最多有 () 个结点。",
"option_A": "2k",
"option_B": "2^(k-1)",
"option_C": "2^k-1",
"option_D": "2k-1",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "二叉树的存储结构",
"question": "用顺序存储的方法，将完全二叉树中所有结点按层逐个从左到右的顺序存放在一维数组 R [1..N] 中，若结点 R [i] 有右孩子，则其右孩子是 ()。",
"option_A": "R [2i-1]",
"option_B": "R [2i+1]",
"option_C": "R [2i]",
"option_D": "R [2/i]",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "设 a,b 为一棵二叉树上的两个结点，在中序遍历时，a 在 b 前面的条件是 ()。",
"option_A": "a 在 b 的右方",
"option_B": "a 在 b 的左方",
"option_C": "a 是 b 的祖先",
"option_D": "a 是 b 的子孙",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "设一棵二叉树的中序遍历序列:badce, 后序遍历序列:bdeca, 则二叉树先序遍历序列为 ()。",
"option_A": "adbce",
"option_B": "decab",
"option_C": "debac",
"option_D": "abcde",
"answer": "D",
"difficulty": 6,
"bloom_level": "d"
},
{
"knowledge_point_type": "二叉树的定义及其主要特性",
"question": "在一棵具有 5 层的满二叉树中结点总数为 ()。",
"option_A": "31",
"option_B": "32",
"option_C": "33",
"option_D": "16",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "由二叉树的前序和后序遍历序列 () 惟一确定这棵二叉树。",
"option_A": "能",
"option_B": "不能",
"option_C": "无法确定",
"option_D": "以上均不对",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "某二叉树的中序序列为 ABCDEFG, 后序序列为 BDCAFGE, 则其左子树中结点数目为 ()。",
"option_A": "3",
"option_B": "2",
"option_C": "4",
"option_D": "5",
"answer": "C",
"difficulty": 6,
"bloom_level": "d"
},
{
"knowledge_point_type": "哈夫曼树和哈夫曼编码",
"question": "若以 (4,5,6,7,8) 作为权值构造哈夫曼树，则该树的带权路径长度为 ()。",
"option_A": "67",
"option_B": "68",
"option_C": "69",
"option_D": "70",
"answer": "C",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "二叉树的存储结构",
"question": "将一棵有 100 个结点的完全二叉树从根这一层开始，每一层上从左到右依次对结点进行编号，根结点的编号为 1, 则编号为 49 的结点的左孩子编号为 ()。",
"option_A": "98",
"option_B": "99",
"option_C": "50",
"option_D": "48",
"answer": "A",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "栈在表达式求值中的应用",
"question": "表达式 a*(b+c)-d÷ 的后缀表达式是 ()。",
"option_A": "abcd+",
"option_B": "abc+d",
"option_C": "abc+d",
"option_D": "-+abcd",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "对某二叉树进行先序遍历的结果为 ABDEFC, 中序遍历的结果为 DBFEAC, 则后序遍历的结果是 ()。",
"option_A": "DBFEAC",
"option_B": "DFEBCA",
"option_C": "BDFECA",
"option_D": "BDEFAC",
"answer": "B",
"difficulty": 6,
"bloom_level": "d"
},
{
"knowledge_point_type": "树的定义",
"question": "树最适合用来表示 ()。",
"option_A": "有序数据元素",
"option_B": "无序数据元素",
"option_C": "元素之间具有分支层次关系的数据",
"option_D": "元素之间无联系的数据",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "栈在表达式求值中的应用",
"question": " 表达式 A(B+C)/(D-E+F) 的后缀表达式是 ()。",
"option_A": "AB+C/D-E+F",
"option_B": "ABC+D/E-F+",
"option_C": "ABC+DE-F+/",
"option_D": "ABCDED+/-+",
"answer": "C",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "线索二叉树",
"question": "在线索二叉树中，t 所指结点没有左子树的充要条件是 ()。",
"option_A": "t->left=NULL",
"option_B": "t->ltag==1",
"option_C": "t->ltag==1&&t->left==NULL",
"option_D": "以上都不对",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "任何一棵二叉树的叶结点在先序、中序和后序遍历序列中的相对次序 ()。",
"option_A": "不发生改变",
"option_B": "发生改变",
"option_C": "不能确定",
"option_D": "以上都不对",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "二叉树的定义及其主要特性",
"question": "假定在一棵二叉树中，度为 2 的结点数为 15, 度为 1 的结点数为 30, 则叶子结点数为 () 个。",
"option_A": "15",
"option_B": "16",
"option_C": "17",
"option_D": "47",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "二叉树的定义",
"question": "在下列情况中，可称为二叉树的是 ()。",
"option_A": "每个结点至多有两棵子树的树",
"option_B": "哈夫曼树",
"option_C": "每个结点至多有两棵子树的有序树",
"option_D": "每个结点只有一棵子树",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "二叉树的存储结构",
"question": "用顺序存储的方法，将完全二叉树中所有结点按层逐个从左到右的顺序存放在一维数组 R [1..N] 中，若结点 R [i] 有左孩子，则其左孩子是 ()。",
"option_A": "R [2i-1]",
"option_B": "R [2i+1]",
"option_C": "R [2i]",
"option_D": "R [2/i]",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "二叉树的定义",
"question": "下面说法中正确的是 ()。",
"option_A": "度为 2 的树是二叉树",
"option_B": "度为 2 的有序树是二叉树",
"option_C": "子树有严格左右之分的树是二叉树",
"option_D": "子树有严格左右之分，且度不超过 2 的树是二叉树",
"answer": "D",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "树、森林与二叉树的转换",
"question": "树的先根序列等同于与该树对应的二叉树的 ()。",
"option_A": "先序序列",
"option_B": "中序序列",
"option_C": "后序序列",
"option_D": "层序序列",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "二叉树的定义",
"question": "按照二叉树的定义，具有 3 个结点的二叉树有 () 种。",
"option_A": "3",
"option_B": "4",
"option_C": "5",
"option_D": "6",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "哈夫曼树和哈夫曼编码",
"question": "由权值为 3,6,7,2,5 的叶子结点生成一棵哈夫曼树，它的带权路径长度为 ()。",
"option_A": "51",
"option_B": "23",
"option_C": "53",
"option_D": "74",
"answer": "A",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "在二叉树后序遍历中，任一个结点均在其子女结点后面，这种说法（ ）。",
"optionoption_A": "正确",
"option_B": "不正确",
"option_C": "无法判断",
"option_D": "以上均不对",
"answer": "A",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "在二叉树先序遍历中，任一个结点均在其子女结点前面，这种说法（ ）。",
"option_A": "正确",
"option_B": "不正确",
"option_C": "无法判断",
"option_D": "以上均不对",
"answer": "A",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "二叉树的性质",
"question": "设深度为 h 的二叉树上只有叶子结点和同时具有左右子树的结点，则此类二叉树中所包含的结点数目至少为（ ）。",
"option_A": "2h",
"option_B": "2h",
"option_C": "2h＋1",
"option_D": "2h-l",
"answer": "D",
"difficulty": 4,
"bloom_level": "c"
},
{
"knowledge_point_type": "二叉树的性质",
"question": "二叉村第 k 层上最多有（ ）个结点。",
"option_A": "2k",
"option_B": "2k-1",
"option_C": "2k-1",
"option_D": "2k+1",
"answer": "C",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "二叉树的性质",
"question": "二叉树的深度为 k，则二叉树最多有（ ）个结点。",
"option_A": "2k",
"option_B": "2k-1",
"option_C": "2k-1",
"option_D": "2k -1",
"answer": "C",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "设某一二叉树先序遍历为 abdec，中序遍历为 dbeac，则该二叉树后序遍历的顺序是（ ）。",
"option_A": "abdec",
"option_B": "debac",
"option_C": "debca",
"option_D": "abedc",
"answer": "C",
"difficulty": 5,
"bloom_level": "d"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "设某一二叉树中序遍历为 badce，后序遍历为 bdeca，则该二叉树先序遍历的顺序是（ ）。",
"option_A": "adbec",
"option_B": "decab",
"option_C": "debac",
"option_D": "abode",
"answer": "D",
"difficulty": 5,
"bloom_level": "d"
},
{
"knowledge_point_type": "树、森林与二叉树的转换",
"question": "将一棵树 T 转换为一棵二叉树 T2，则 T 的先序遍历是 T2 的（ ）。",
"option_A": "先序",
"option_B": "中序",
"option_C": "后序",
"option_D": "无法确定",
"answer": "A",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "树、森林与二叉树的转换",
"question": "将一棵树 T 转换为一棵二叉树 T2，则 T 的后序遍历是 T2 的（ ）。",
"option_A": "先序",
"option_B": "中序",
"option_C": "后序",
"option_D": "无法碉定",
"answer": "B",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "树的定义",
"question": "树最适合于用来表示（ ）。",
"option_A": "线性结构的数据",
"option_B": "顺序结构的数据",
"option_C": "元素之间无前驱和后继关系的数据",
"option_D": "元素之间有包含和层次关系的数据",
"answer": "D",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "二叉树的叶子结点在先序、中序和后序遍历过程中的相对秩序（ ）。",
"option_A": "发生改变",
"option_B": "不发生改变",
"option_C": "无法确定",
"option_D": "以上均不正确",
"answer": "B",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "二叉树的性质",
"question": "设一棵二叉树度为 2 的结点数是 7，度为 1 的结点数是 6，则叶子结点数是（ ）。",
"option_A": "6",
"option_B": "7",
"option_C": "8",
"option_D": "9",
"answer": "C",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "完全二叉树的顺序存储",
"question": "用顺序存储的方法，将完全二叉树中所有结点按层逐个从左到右的顺序存放在一维数组 R [1．．n] 中，若结点 R [i] 有左孩子，则其左孩子是（ ）。",
"option_A": "R [2i-1]",
"option_B": "R [2i+1]",
"option_C": "R [2i]",
"option_D": "R [2/i]",
"answer": "C",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "完全二叉树的顺序存储",
"question": "用顺序存储的方法，将完全二叉树中所有结点按层逐个从左到右的顺序存放在一维数组 R [1．．n] 中，若结点 R [i] 有右孩子，则其右孩子是（ ）。",
"option_A": "R [2i-1]",
"option_B": "R [2i＋l]",
"option_C": "R [2i]",
"option_D": "R [2/i]",
"answer": "B",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "一棵非空的二叉树，先序遍历与后序遍历正好相反，则该二叉树满足（ ）。",
"option_A": "无左孩子",
"option_B": "无右孩子",
"option_C": "只有一个叶子结点",
"option_D": "任意二叉树",
"answer": "C",
"difficulty": 4,
"bloom_level": "c"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "设 a、b 为一棵二叉树的两个结点，在后序遍历中，a 在 b 前的条件是（ ）。",
"option_A": "a 在 b 上方",
"option_B": "a 在 b 下方",
"option_C": "a 在 b 左方",
"option_D": "a 在 b 右方",
"answer": "C",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "线索二叉树",
"question": "线索二叉树是一种（ ）。",
"option_A": "逻辑结构",
"option_B": "线性结构",
"option_C": "逻辑和线性结构",
"option_D": "物理结构",
"answer": "D",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "线索二叉树",
"question": "N 个结点的线索二叉树中，线索的数目是（ ）。",
"option_A": "N-1",
"option_B": "N＋1",
"option_C": "2N",
"option_D": "2N－1",
"answer": "B",
"difficulty": 4,
"bloom_level": "c"
},
{
"knowledge_point_type": "哈夫曼树和哈夫曼编码",
"question": "权值为｛l，2，6，8｝的四个结点构成的哈夫曼树的带权路径长度是（ ）。",
"option_A": "18",
"option_B": "28",
"option_C": "19",
"option_D": "29",
"answer": "B",
"difficulty": 4,
"bloom_level": "c"
},
{
"knowledge_point_type": "线索二叉树",
"question": "实现任意二叉树的后序遍历的非递归算法而不使用栈结构，最佳方案是二叉村采用（ ）存储结构。",
"option_A": "二叉链表",
"option_B": "广义表存储结构",
"option_C": "三叉链表",
"option_D": "顺序存储结构",
"answer": "C",
"difficulty": 5,
"bloom_level": "d"
},
{
"knowledge_point_type": "满二叉树的性质",
"question": "对一个满二叉树，m 个树叶，k 个分枝结点，n 个结点，则（ ）。",
"option_A": "n＝m＋1",
"option_B": "m+1=2n",
"option_C": "m＝k-1",
"option_D": "n=2k+1",
"answer": "D",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "平衡二叉树",
"question": "具有五层结点的二叉平衡树至少有（ ）个结点。",
"option_A": "10",
"option_B": "12",
"option_C": "15",
"option_D": "17",
"answer": "B",
"difficulty": 5,
"bloom_level": "d"
},
{
"knowledge_point_type": "二叉树的遍历",
"question": "设 n，m 为一棵二叉树上的二个结点，在中序遍历时，n 在 m 前的条件是（ ）。",
"option_A": "n 在 m 右方",
"option_B": "n 是 m 祖先",
"option_C": "n 在 m 左方",
"option_D": "n 是 m 子孙",
"answer": "C",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "线索二叉树",
"question": "线索二又树是一种（ ）结构。",
"option_A": "逻辑",
"option_B": "逻辑和物理",
"option_C": "物理",
"option_D": "线性",
"answer": "C",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "完全二叉树的顺序存储",
"question": "将一棵有 100 个结点的完全二又树从根这一层开始，每一层上从左到右依次对结点进行编号，根结点的编号为 1，则编号为 49 的结点的左孩子编号为（ ）。",
"option_A": "98",
"option_B": "99",
"option_C": "50",
"option_D": "48",
"answer": "A",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "图的存储结构 - 邻接矩阵法",
"question": "对于具有 n 个顶点的图，若采用邻接矩阵表示，则该矩阵的大小为 ()。",
"option_A": "n",
"option_B": "n×n",
"option_C": "n-1",
"option_D": "(n-1)²",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "图的遍历与图的连通性",
"question": "如果从无向图的任一顶点出发进行一次深度优先搜索即可访问所有顶点，则该图一定是 ()。",
"option_A": "完全图",
"option_B": "连通图",
"option_C": "有回路",
"option_D": "一棵树",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "关键路径",
"question": "关键路径是事件结点网络中 ()。",
"option_A": "从源点到汇点的最长路径",
"option_B": "从源点到汇点的最短路径",
"option_C": "最长的回路",
"option_D": "最短的回路",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "拓扑排序",
"question": "下面 () 可以判断出一个有向图中是否有环 (回路)。",
"option_A": "广度优先遍历",
"option_B": "拓扑排序",
"option_C": "求最短路径",
"option_D": "求关键路径",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "图的存储结构 - 邻接矩阵法",
"question": "带权有向图 G 用邻接矩阵 A 存储，则顶点 i 的入度等于 A 中 ()。",
"option_A": "第 i 行非无穷的元素之和",
"option_B": "第 i 列非无穷的元素个数之和",
"option_C": "第 i 行非无穷且非 0 的元素个数",
"option_D": "第 i 行与第 i 列非无穷且非 0 的元素之和",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "图的遍历 - 深度优先搜索",
"question": "采用邻接表存储的图，其深度优先遍历类似于二叉树的 ()。",
"option_A": "中序遍历",
"option_B": "先序遍历",
"option_C": "后序遍历",
"option_D": "按层次遍历",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "图的存储结构 - 邻接矩阵法",
"question": "无向图的邻接矩阵是一个 ()。",
"option_A": "对称矩阵",
"option_B": "零矩阵",
"option_C": "上三角矩阵",
"option_D": "对角矩阵",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "队列的顺序存储结构",
"question": "当利用大小为 N 的数组存储循环队列时，该队列的最大长度为 ()。",
"option_A": "N",
"option_B": "N+1",
"option_C": "N-1",
"option_D": "N-2",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "图的存储结构 - 邻接表法",
"question": "邻接表是图的一种 ()。",
"option_A": "顺序存储结构",
"option_B": "链式存储结构",
"option_C": "索引存储结构",
"option_D": "散列存储结构",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "拓扑排序",
"question": "下面有向图所示的拓扑排序的结果序列是 ()。",
"option_A": "125634",
"option_B": "516234",
"option_C": "123456",
"option_D": "521643",
"answer": "A",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "图的基本概念",
"question": "在无向图中定义顶点 vi 与 vj 之间的路径为从 vi 到 vj 的一个 ()。",
"option_A": "顶点序列",
"option_B": "边序列",
"option_C": "权值总和",
"option_D": "边的条数",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "图的存储结构 - 邻接表法",
"question": "在有向图的逆邻接表中，每个顶点邻接表链接着该顶点所有 () 邻接点。",
"option_A": "入边",
"option_B": "出边",
"option_C": "入边和出边",
"option_D": "不是出边也不是入边",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "图的基本概念",
"question": " 设 G1=(V 1,E1)和 G2=(V2 ,E2)为两个图，如果V1⊆V2, E1⊆E2则称 ()。",
"option_A": "G1 是 G2 的子图",
"option_B": "G2 是 G1 的子图",
"option_C": "G1 是 G2 的连通分量",
"option_D": "G2 是 G1 的连通分量",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "图的存储结构 - 邻接矩阵法",
"question": "已知一个有向图的邻接矩阵表示，要删除所有从第 i 个结点发出的边，应 ()。",
"option_A": "将邻接矩阵的第 i 行删除",
"option_B": "将邻接矩阵的第 i 行元素全部置为 0",
"option_C": "将邻接矩阵的第 i 列删除",
"option_D": "将邻接矩阵的第 i 列元素全部置为 0",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "拓扑排序",
"question": "任一个有向图的拓扑序列 ()。",
"option_A": "不存在",
"option_B": "有一个",
"option_C": "一定有多个",
"option_D": "有一个或多个",
"answer": "D",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "图的基本概念",
"question": "在一个无向图 G 中，所有顶点的度数之和等于所有边数之和的（ ）倍。",
"option_A": "l/2",
"option_B": "1",
"option_C": "2",
"option_D": "4",
"answer": "C",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "图的基本概念",
"question": "在一个有向图中，所有顶点的入度之和等于所有顶点的出度之和的（）倍。",
"option_A": "l/2",
"option_B": "1",
"option_C": "2",
"option_D": "4",
"answer": "B",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "图的连通性",
"question": "一个具有 n 个顶点的无向联通图至少包含（ ）条边。",
"option_A": "n",
"option_B": "n＋1",
"option_C": "n-1",
"option_D": "n/2",
"answer": "C",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "完全图的概念",
"question": "一个具有 n 个顶点的无向完全图包含（ ）条边。",
"option_A": "n (n-l)",
"option_B": "n (n+l)",
"option_C": "n (n-l)/2",
"option_D": "n (n+l)/2",
"answer": "C",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "完全图的概念",
"question": "一个具有 n 个顶点的有向完全图包含（ ）条边。",
"option_A": "n (n-1)",
"option_B": "n (n+l)",
"option_C": "n (n-l)/2",
"option_D": "n (n+l)/2",
"answer": "A",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "图的存储结构",
"question": "对于具有 n 个顶点的图，若采用邻接矩阵表示，则该矩阵的大小为（ ）。",
"option_A": "n",
"option_B": "n²",
"option_C": "n-1",
"option_D": "(n-l)²",
"answer": "B",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "邻接表法",
"question": "对于一个具有 n 个顶点和 e 条边的无向图，若采用邻接表表示，则表头向量的大小为（ ）。",
"option_A": "n",
"option_B": "e",
"option_C": "2n",
"option_D": "2e",
"answer": "A",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "邻接表法",
"question": "对于一个具有 n 个顶点和 e 条边的无向图，若采用邻接表表示，则所有顶点邻接表中的结点总数为（ ）。",
"option_A": "n",
"option_B": "e",
"option_C": "2n",
"option_D": "2e",
"answer": "D",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "邻接表法",
"question": "在有向图的邻接表中，每个顶点邻接链表链接着该顶点所有（ ）邻接点。",
"option_A": "入边",
"option_B": "出边",
"option_C": "入边和出边",
"option_D": "不是入边也不是出边",
"answer": "B",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "逆邻接表法",
"question": "在有向图的逆邻接表中，每个顶点邻接链表链接着该顶点所有（ ）邻接点。",
"option_A": "入边",
"option_B": "出边",
"option_C": "入边和出边",
"option_D": "不是人边也不是出边",
"answer": "A",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "图的遍历",
"question": "下列说法中不正确的是（ ）。",
"option_A": "无向图中的极大连通子图称为连通分量",
"option_B": "连通图的广度优先搜索中一般要采用队列来暂存刚访问过的顶点",
"option_C": "图的深度优先搜索中一般要采用栈来暂存刚访问过的顶点",
"option_D": "有向图的遍历不可采用广度优先搜索方法",
"answer": "D",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "生成树的概念",
"question": "设无向连通图 G=(V, E) 和 G’= (V’, E’)，如果 G’为 G 的生成树，则下列说法中不正确的是（ ）。",
"option_A": "G’为 G 的连通分量",
"option_B": "G’为 G 的无环子图",
"option_C": "G’为 G 的子图",
"option_D": "G’为 G 的极小连通子图且 V’＝V",
"answer": "A",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "图的连通性",
"question": "如果无向图 G 必须进行二次广度优先搜索才能访问其所有顶点，则下列说法中不正确的是（ ）。",
"option_A": "G 肯定不是完全图",
"option_B": "G 一定不是连通图",
"option_C": "G 中一定有回路",
"option_D": "G 有二个连通分量",
"answer": "C",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "图的存储结构",
"question": "邻接表是图的一种（ ）。",
"option_A": "顺序存储结构",
"option_B": "链式存储结构",
"option_C": "索引存储结构",
"option_D": "散列存储结构",
"answer": "B",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "图的连通性",
"question": "如果从无向图的任一顶点出发进行一次深度优先搜索即可访问所有顶点，则该图一定是（ ）。",
"option_A": "完全图",
"option_B": "连通图",
"option_C": "有回路",
"option_D": "一棵树",
"answer": "B",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "图的遍历",
"question": "下列有关图遍历的说法不正确的是（ ）。",
"option_A": "连通图的深度优先搜索是一个递归过程",
"option_B": "图的广度优先搜索中邻接点的寻找具有 “先进先出” 的特征",
"option_C": "非连通图不能用深度优先搜索法",
"option_D": "图的遍历要求每一顶点仅被访问一次",
"answer": "C",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "生成树的概念",
"question": "一个无向连通图的生成树是含有该连通图的全部顶点的（ ）。",
"option_A": "极小连通子图",
"option_B": "极小子图",
"option_C": "极大连通子图",
"option_D": "极大子图",
"answer": "A",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "邻接矩阵法",
"question": "无向图的邻接矩阵是一个（ ）。",
"option_A": "对称矩阵",
"option_B": "零矩阵",
"option_C": "上三角矩阵",
"option_D": "对角矩阵",
"answer": "A",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "图的深度优先搜索",
"question": "已知一个图如下图所示，若从顶点 a 出发按深度优先搜索法进行遍历，则可能得到的一种顶点序列为（ ）。",
"option_A": "abecdf",
"option_B": "acfebd",
"option_C": "acebfd",
"option_D": "acfdeb",
"answer": "C",
"difficulty": 4,
"bloom_level": "c"
},
{
            "knowledge_point_type": "图的基本概念",
            "question": "在一个有向图中,所有顶点的入度之和等于所有顶点的出度之和的()倍。",
            "option_A": "1/2",
            "option_B": "1",
            "option_C": "2",
            "option_D": "4",
            "answer": "B",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的遍历-广度优先搜索",
            "question": "图的广度优先遍历类似于二叉树的()。",
            "option_A": "先序遍历",
            "option_B": "中序遍历",
            "option_C": "后序遍历",
            "option_D": "层序遍历",
            "answer": "D",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的遍历-深度优先搜索",
            "question": "图的深度优先遍历类似于二叉树的()。",
            "option_A": "先序遍历",
            "option_B": "中序遍历",
            "option_C": "后序遍历",
            "option_D": "层序遍历",
            "answer": "A",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "最小生成树-Prim算法",
            "question": "用Prim算法求一个连通的带权图的最小代价生成树,在算法执行的某时刻,已选取的顶点集合U={1,2,3},已选取的边集合TE={(1,2),(2,3)},要选取下一条权值最小的边,应当从()组中选取。",
            "option_A": "所有顶点u∈U,顶点v∈V-U的边(u,v)",
            "option_B": "所有顶点u∈V-U,顶点v∈V-U的边(u,v)",
            "option_C": "所有顶点u∈V-U,顶点v∈U的边(u,v)",
            "option_D": "所有顶点u∈U,顶点v∈U的边(u,v)",
            "answer": "A",
            "difficulty": 4,
            "bloom_level": "b"
        },
        {
            "knowledge_point_type": "图的基本概念",
            "question": "在一个具有n个顶点的无向完全图中,包含有()条边。",
            "option_A": "n(n-1)/2",
            "option_B": "n(n-1)",
            "option_C": "n(n+1)/2",
            "option_D": "n²",
            "answer": "A",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的基本概念",
            "question": "在一个具有n个顶点的有向完全图中,包含有()条边。",
            "option_A": "n(n-1)/2",
            "option_B": "n(n-1)",
            "option_C": "n(n+1)/2",
            "option_D": "n²",
            "answer": "B",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "关键路径",
            "question": "在AOE网中,关键路径上活动的时间延长多少,整个工程的时间也就随之延长多少。因此,要想缩短整个工程的工期,必须加快()上活动的进度。",
            "option_A": "最短路径",
            "option_B": "最长路径",
            "option_C": "关键路径",
            "option_D": "所有路径",
            "answer": "C",
            "difficulty": 4,
            "bloom_level": "b"
        },
        {
            "knowledge_point_type": "最短路径-Dijkstra算法",
            "question": "Dijkstra算法用于求解图中()。",
            "option_A": "所有顶点到某一顶点的最短路径",
            "option_B": "某一顶点到所有顶点的最短路径",
            "option_C": "所有顶点到所有顶点的最短路径",
            "option_D": "图的最小生成树",
            "answer": "B",
            "difficulty": 4,
            "bloom_level": "b"
        },
        {
            "knowledge_point_type": "最短路径-Floyd算法",
            "question": "Floyd算法用于求解图中()。",
            "option_A": "所有顶点到某一顶点的最短路径",
            "option_B": "某一顶点到所有顶点的最短路径",
            "option_C": "所有顶点到所有顶点的最短路径",
            "option_D": "图的最小生成树",
            "answer": "C",
            "difficulty": 4,
            "bloom_level": "b"
        },
        {
            "knowledge_point_type": "图的存储结构-邻接表法",
            "question": "在有向图的邻接表存储结构中,顶点v在邻接表中出现的次数是()。",
            "option_A": "顶点v的度",
            "option_B": "顶点v的出度",
            "option_C": "顶点v的入度",
            "option_D": "依附于顶点v的边数",
            "answer": "C",
            "difficulty": 4,
            "bloom_level": "b"
        },
        {
            "knowledge_point_type": "最小生成树-Kruskal算法",
            "question": "Kruskal算法的时间复杂度为()。",
            "option_A": "O(n)",
            "option_B": "O(n²)",
            "option_C": "O(eloge)",
            "option_D": "O(n³)",
            "answer": "C",
            "difficulty": 4,
            "bloom_level": "b"
        },
        {
            "knowledge_point_type": "最小生成树-Prim算法",
            "question": "Prim算法的时间复杂度为()。",
            "option_A": "O(n)",
            "option_B": "O(n²)",
            "option_C": "O(eloge)",
            "option_D": "O(n³)",
            "answer": "B",
            "difficulty": 4,
            "bloom_level": "b"
        },
        {
            "knowledge_point_type": "图的遍历-深度优先搜索",
            "question": "对于一个具有n个顶点和e条边的无向图,若采用邻接表表示,则所有顶点邻接表中的边结点总数为()。",
            "option_A": "e/2",
            "option_B": "e",
            "option_C": "2e",
            "option_D": "n+e",
            "answer": "C",
            "difficulty": 4,
            "bloom_level": "b"
        },
        {
            "knowledge_point_type": "图的遍历-广度优先搜索",
            "question": "广度优先遍历类似于二叉树的()。",
            "option_A": "先序遍历",
            "option_B": "中序遍历",
            "option_C": "后序遍历",
            "option_D": "层次遍历",
            "answer": "D",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的基本概念",
            "question": "在一个无向图中,所有顶点的度数之和等于边数的()倍。",
            "option_A": "1/2",
            "option_B": "1",
            "option_C": "2",
            "option_D": "4",
            "answer": "C",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的存储结构-邻接矩阵法",
            "question": "在一个有n个顶点的无向图中,若采用邻接矩阵表示,则该矩阵的大小为()。",
            "option_A": "n",
            "option_B": "n×n",
            "option_C": "n-1",
            "option_D": "n+1",
            "answer": "B",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的存储结构-邻接表法",
            "question": "在一个有n个顶点和e条边的无向图中,若采用邻接表表示,则表头向量的大小为()。",
            "option_A": "n",
            "option_B": "n+1",
            "option_C": "n-1",
            "option_D": "e",
            "answer": "A",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的存储结构-邻接表法",
            "question": "在一个有n个顶点和e条边的无向图中,若采用邻接表表示,则表中的边结点总数为()。",
            "option_A": "e/2",
            "option_B": "e",
            "option_C": "2e",
            "option_D": "n+e",
            "answer": "C",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的遍历-深度优先搜索",
            "question": "已知一个图的邻接表存储结构,若要删除所有从顶点v发出的边,则需要遍历()。",
            "option_A": "整个邻接表",
            "option_B": "邻接表中顶点v的单链表",
            "option_C": "邻接表中所有顶点的单链表",
            "option_D": "邻接表中顶点v的单链表和所有顶点的单链表",
            "answer": "B",
            "difficulty": 4,
            "bloom_level": "b"
        },
        {
            "knowledge_point_type": "图的遍历-广度优先搜索",
            "question": "在图的广度优先遍历算法中,需要使用的辅助数据结构是()。",
            "option_A": "栈",
            "option_B": "队列",
            "option_C": "树",
            "option_D": "图",
            "answer": "B",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的遍历-深度优先搜索",
            "question": "在图的深度优先遍历算法中,需要使用的辅助数据结构是()。",
            "option_A": "栈",
            "option_B": "队列",
            "option_C": "树",
            "option_D": "图",
            "answer": "A",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的基本概念",
            "question": "一个有n个顶点的无向连通图,其边数至少为()。",
            "option_A": "n-1",
            "option_B": "n",
            "option_C": "n+1",
            "option_D": "nlogn",
            "answer": "A",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的基本概念",
            "question": "一个有n个顶点的有向强连通图,其边数至少为()。",
            "option_A": "n-1",
            "option_B": "n",
            "option_C": "n+1",
            "option_D": "n(n-1)",
            "answer": "B",
            "difficulty": 4,
            "bloom_level": "b"
        },
        {
            "knowledge_point_type": "图的遍历-深度优先搜索",
            "question": "在一个有向图中,若存在一个顶点v,从该顶点出发可以到达图中所有其他顶点,则称该图为()。",
            "option_A": "强连通图",
            "option_B": "弱连通图",
            "option_C": "单侧连通图",
            "option_D": "连通图",
            "answer": "C",
            "difficulty": 4,
            "bloom_level": "b"
        },
        {
            "knowledge_point_type": "图的遍历-深度优先搜索",
            "question": "在一个有向图中,若对于每一对顶点u和v,都存在从u到v和从v到u的路径,则称该图为()。",
            "option_A": "强连通图",
            "option_B": "弱连通图",
            "option_C": "单侧连通图",
            "option_D": "连通图",
            "answer": "A",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的遍历-深度优先搜索",
            "question": "在一个有向图中,若将其边视为无向边后得到的无向图是连通的,则称该有向图为()。",
            "option_A": "强连通图",
            "option_B": "弱连通图",
            "option_C": "单侧连通图",
            "option_D": "连通图",
            "answer": "B",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的基本概念",
            "question": "在一个具有n个顶点的无向图中,若要保证图是连通的,则至少需要()条边。",
            "option_A": "n-1",
            "option_B": "n(n-1)/2",
            "option_C": "n(n-1)",
            "option_D": "n",
            "answer": "A",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的基本概念",
            "question": "在一个具有n个顶点的有向图中,若要保证图是强连通的,则至少需要()条边。",
            "option_A": "n-1",
            "option_B": "n",
            "option_C": "n(n-1)/2",
            "option_D": "n(n-1)",
            "answer": "B",
            "difficulty": 4,
            "bloom_level": "b"
        },
        {
            "knowledge_point_type": "图的遍历-深度优先搜索",
            "question": "在一个有向图中,若存在一个顶点v,从该顶点出发可以到达图中所有其他顶点,则称该图为()。",
            "option_A": "强连通图",
            "option_B": "弱连通图",
            "option_C": "单侧连通图",
            "option_D": "连通图",
            "answer": "C",
            "difficulty": 4,
            "bloom_level": "b"
        },
        {
            "knowledge_point_type": "图的遍历-深度优先搜索",
            "question": "在一个有向图中,若对于每一对顶点u和v,都存在从u到v和从v到u的路径,则称该图为()。",
            "option_A": "强连通图",
            "option_B": "弱连通图",
            "option_C": "单侧连通图",
            "option_D": "连通图",
            "answer": "A",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的遍历-深度优先搜索",
            "question": "在一个有向图中,若将其边视为无向边后得到的无向图是连通的,则称该有向图为()。",
            "option_A": "强连通图",
            "option_B": "弱连通图",
            "option_C": "单侧连通图",
            "option_D": "连通图",
            "answer": "B",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的基本概念",
            "question": "在一个具有n个顶点的无向图中,若要保证图是连通的,则至少需要()条边。",
            "option_A": "n-1",
            "option_B": "n(n-1)/2",
            "option_C": "n(n-1)",
            "option_D": "n",
            "answer": "A",
            "difficulty": 3,
            "bloom_level": "a"
        },
        {
            "knowledge_point_type": "图的基本概念",
            "question": "在一个具有n个顶点的有向图中,若要保证图是强连通的,则至少需要()条边。",
            "option_A": "n-1",
            "option_B": "n",
            "option_C": "n(n-1)/2",
            "option_D": "n(n-1)",
            "answer": "B",
            "difficulty": 4,
            "bloom_level": "b"
        },
{
"knowledge_point_type": "顺序查找",
"question": "在顺序表中进行顺序查找，其平均查找长度为 ()。",
"option_A": "(n+1)/2",
"option_B": "n/2",
"option_C": "n",
"option_D": "log₂n",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "折半查找",
"question": "对长度为 n 的有序顺序表进行折半查找，其平均查找长度为 ()。",
"option_A": "O (log₂n)",
"option_B": "O (n)",
"option_C": "O (nlog₂n)",
"option_D": "O (n²)",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "折半查找",
"question": "折半查找有序表 (4,6,10,12,18,20,24,26,30,32,36), 若查找元素 20, 需进行 () 次比较。",
"option_A": 2,
"option_B": 3,
"option_C": 4,
"option_D": 5,
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "分块查找",
"question": "分块查找中，若索引表和块内均采用顺序查找，则其平均查找长度为 ()。",
"option_A": "O (log₂n)",
"option_B": "O (√n)",
"option_C": "O (n)",
"option_D": "O (nlog₂n)",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "二叉排序树 (BST)",
"question": "在二叉排序树中，左子树上所有结点的值均 () 根结点的值。",
"option_A": "<",
"option_B": ">",
"option_C": "=",
"option_D": "≤",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "二叉排序树 (BST)",
"question": "在二叉排序树中，右子树上所有结点的值均 () 根结点的值。",
"option_A": ">",
"option_B": "<",
"option_C": "=",
"option_D": "≤",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "二叉排序树 (BST)",
"question": "在二叉排序树中，中序遍历序列是 () 序列。",
"option_A": "无序",
"option_B": "有序",
"option_C": "逆序",
"option_D": "随机",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "平衡二叉树",
"question": "平衡二叉树中每个结点的平衡因子的绝对值不超过 ()。",
"option_A": 0,
"option_B": 1,
"option_C": 2,
"option_D": 3,
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "顺序查找",
"question": "顺序查找方法适合于存储结构为（ ）的线性表",
"option_A": "散列存储",
"option_B": "索引存储",
"option_C": "散列存储或索引存储",
"option_D": "顺序存储或链接存储",
"answer": "D",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "折半查找",
"question": "对线性表进行二分查找的时候，要求线性表必须（ ）。",
"option_A": "以顺序存储方式",
"option_B": "以链接存储方式",
"option_C": "以顺序存储方式，且数据元素有序",
"option_D": "以链接存储方式，且数据元素有序",
"answer": "C",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "分块查找",
"question": "如果要求一个线性表既能较快地查找，又能动态适应变化要求，可以采用（ ）查找方法。",
"option_A": "顺序",
"option_B": "分块",
"option_C": "折半",
"option_D": "散列",
"answer": "B",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "线性表的存储结构",
"question": "对于一个线性表，若要求既能进行较快地插入和删除，又要求存储结构能够反映数据元素之间的逻辑关系，则应该 ( ) 。",
"option_A": "以顺序存储方式",
"option_B": "以链接存储方式",
"option_C": "以索引存储方式",
"option_D": "以散列存储方式",
"answer": "B",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "顺序表的特点",
"question": "在线性表的存储结构中，（ ）查找、插入和删除速度慢，但顺序存储和随机存取第 i 个元素速度快。",
"option_A": "顺序表",
"option_B": "链接表",
"option_C": "散列表",
"option_D": "索引表",
"answer": "A",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "顺序表的特点",
"question": "在 ( ) 上查找和存取速度快，但插入和删除速度慢。",
"option_A": "顺序表",
"option_B": "链接表",
"option_C": "顺序有序表",
"option_D": "散列表",
"answer": "A",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "散列表的特点",
"question": "在 ( ) 上查找、插入和删除速度快，但不能进行顺序存取。",
"option_A": "顺序表",
"option_B": "链接表",
"option_C": "顺序有序表",
"option_D": "散列表",
"answer": "D",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "链接表的特点",
"question": "在 ( ) 上插入、删除和顺序存取速度快，但查找速度慢。",
"option_A": "顺序表",
"option_B": "链接表",
"option_C": "顺序有序表",
"option_D": "散列表",
"answer": "B",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "顺序查找的性能",
"question": "采用顺序查找方法查找长度为 n 的线性表，查找每个元素的平均比较次数为 ( )",
"option_A": "n",
"option_B": "n/2",
"option_C": "(n+1)/2",
"option_D": "(n-1)/2",
"answer": "C",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "顺序查找的时间复杂度",
"question": "顺序查找具有 n 个元素的线性表，其时间复杂度为 ( ) 。",
"option_A": "O (n)",
"option_B": "O (log2n)",
"option_C": "O (n²)",
"option_D": "O (nlog2n)",
"answer": "A",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "折半查找的时间复杂度",
"question": "折半查找具有 n 个元素的线性表，其时间复杂度为 ( ) 。",
"option_A": "O (n)",
"option_B": "O (log2n)",
"option_C": "O (n²)",
"option_D": "O (nlog2n)",
"answer": "B",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "折半查找的应用",
"question": "己知一个有序表为 (11,22,33,44,55,66,77, 88,99), 则折半查找元素 55 需要比较 ( ) 次。",
"option_A": "1",
"option_B": "2",
"option_C": "3",
"option_D": "4",
"answer": "C",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "顺序查找的应用",
"question": "已知一个有序表为 (11,22,33,44,55,66,77,88,99), 则顺序查找元素 55 需要比较 ( ) 次。",
"option_A": "3",
"option_B": "4",
"option_C": "5",
"option_D": "6",
"answer": "C",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "顺序查找和折半查找的存储要求",
"question": "顺序查找法与二分查找法对存储结构的要求是 ( ) 。",
"option_A": "顺序查找与二分查找均只是适用于顺序表",
"option_B": "顺序查找与二分查找均既适用于顺序表，也适用于链表",
"option_C": "顺序查找只是适用于顺序表",
"option_D": "二分查找适用于顺序表",
"answer": "D",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "动态查找表的概念",
"question": "在对查找表的查找过程中，若被查找的数据元素不存在，则把该数据元素插到集合中。这种方式主要适合于 ( ) 。",
"option_A": "静态查找表",
"option_B": "动态查找表",
"option_C": "静态查找表与动态查找表",
"option_D": "两种表都不适合",
"answer": "B",
"difficulty": 2,
"bloom_level": "a"
},
{
"knowledge_point_type": "折半查找的步骤",
"question": "若用二分查找取得的中间位置元素关键字值大于被查找值，则说明被查找值位于中间值的前面，下次的查找区间为从原开始位置至 ( ) 。",
"option_A": "该中间位置",
"option_B": "该中间位置 - 1",
"option_C": "该中间位置 + 1",
"option_D": "该中间位置 1/2",
"answer": "B",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "二叉排序树的遍历",
"question": "二叉排序树（ ）遍历序列是从小到大有序的。",
"option_A": "先序",
"option_B": "中序",
"option_C": "后序",
"option_D": "层序",
"answer": "B",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "B 树及其基本操作",
"question": "m 阶 B 树中每个非叶子结点至少有 () 棵子树。",
"option_A": "m/2",
"option_B": "⌈m/2⌉",
"option_C": "⌊m/2⌋",
"option_D": "m-1",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "二叉排序树 (BST)",
"question": "在二叉排序树中，右子树上所有结点的值均 () 根结点的值。",
"option_A": ">",
"option_B": "<",
"option_C": "=",
"option_D": "≤",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "二叉排序树 (BST)",
"question": "在二叉排序树中，中序遍历序列是 () 序列。",
"option_A": "无序",
"option_B": "有序",
"option_C": "逆序",
"option_D": "随机",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "散列表的基本概念",
"question": "散列函数有一个共同的性质，即函数值应当以 () 概率取其值域的每个值。",
"option_A": "最大",
"option_B": "最小",
"option_C": "均匀",
"option_D": "随机",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "散列表处理冲突的方法",
"question": "处理散列冲突的方法不包括 ()。",
"option_A": "线性探测法",
"option_B": "链地址法",
"option_C": "二分法",
"option_D": "再哈希法",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "散列查找及性能分析",
"question": "散列查找的平均查找长度 ()。",
"option_A": "与处理冲突方法无关",
"option_B": "与散列函数无关",
"option_C": "与散列表长度无关",
"option_D": "与装填因子有关",
"answer": "D",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "排序的定义",
"question": "排序的稳定性是指 ()。",
"option_A": "排序算法的时间复杂度稳定",
"option_B": "排序算法的空间复杂度稳定",
"option_C": "排序前后相同关键字的相对顺序不变",
"option_D": "排序前后相同关键字的绝对顺序不变",
"answer": "C",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "直接插入排序",
"question": "直接插入排序的时间复杂度为 ()。",
"option_A": "O (n)",
"option_B": "O (n²)",
"option_C": "O (nlog₂n)",
"option_D": "O (log₂n)",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "冒泡排序",
"question": "冒泡排序在最好情况下的时间复杂度为 ()。",
"option_A": "O (n)",
"option_B": "O (n²)",
"option_C": "O (nlog₂n)",
"option_D": "O (log₂n)",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "快速排序",
"question": "快速排序在平均情况下的时间复杂度为 ()。",
"option_A": "O (n)",
"option_B": "O (n²)",
"option_C": "O (nlog₂n)",
"option_D": "O (log₂n)",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "简单选择排序",
"question": "简单选择排序的时间复杂度为 ()。",
"option_A": "O (n)",
"option_B": "O (n²)",
"option_C": "O (nlog₂n)",
"option_D": "O (log₂n)",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "堆排序",
"question": "堆排序的时间复杂度为 ()。",
"option_A": "O (n)",
"option_B": "O (n²)",
"option_C": "O (nlog₂n)",
"option_D": "O (log₂n)",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "归并排序",
"question": "归并排序的时间复杂度为 ()。",
"option_A": "O (n)",
"option_B": "O (n²)",
"option_C": "O (nlog₂n)",
"option_D": "O (log₂n)",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "基数排序",
"question": "基数排序的时间复杂度为 ()。",
"option_A": "O (n+k)",
"option_B": "O (n²)",
"option_C": "O (nk)",
"option_D": "O (klog₂n)",
"answer": "C",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "基数排序",
"question": "基数排序的时间复杂度为 ()。",
"option_A": "O (n+k)",
"option_B": "O (n²)",
"option_C": "O (nk)",
"option_D": "O (klog₂n)",
"answer": "C",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "插入排序的稳定性",
"question": "直接插入排序是一种 () 的排序算法。",
"option_A": "不稳定",
"option_B": "稳定",
"option_C": "外部",
"option_D": "非线性",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "快速排序的最坏情况",
"question": "快速排序在最坏情况下的时间复杂度为 ()。",
"option_A": "O (n)",
"option_B": "O (n²)",
"option_C": "O (nlog₂n)",
"option_D": "O (log₂n)",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "归并排序的稳定性",
"question": "归并排序是一种 () 的排序算法。",
"option_A": "不稳定",
"option_B": "稳定",
"option_C": "外部",
"option_D": "选择",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "堆排序的稳定性",
"question": "堆排序是一种 () 的排序算法。",
"option_A": "稳定",
"option_B": "不稳定",
"option_C": "外部",
"option_D": "插入",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "希尔排序的稳定性",
"question": "希尔排序是一种 () 的排序算法。",
"option_A": "稳定",
"option_B": "不稳定",
"option_C": "外部",
"option_D": "交换",
"answer": "B",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "冒泡排序的稳定性",
"question": "冒泡排序是一种 () 的排序算法。",
"option_A": "稳定",
"option_B": "不稳定",
"option_C": "外部",
"option_D": "选择",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "排序算法的比较",
"question": "以下排序算法中，稳定的是 ()。",
"option_A": "快速排序",
"option_B": "堆排序",
"option_C": "归并排序",
"option_D": "希尔排序",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "排序算法的比较",
"question": "以下排序算法中，不稳定的是 ()。",
"option_A": "直接插入排序",
"option_B": "冒泡排序",
"option_C": "简单选择排序",
"option_D": "归并排序",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "外部排序的基本概念",
"question": "外部排序是指 ()。",
"option_A": "排序过程中需访问外存",
"option_B": "不需要使用内存",
"option_C": "排序算法复杂",
"option_D": "排序时间长",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "排序算法的比较次数",
"question": "在所有的排序方法中，关键字比较的次数与记录初始排列秩序无关的是（）。",
"option_A": "冒泡排序",
"option_B": "希尔排序",
"option_C": "直接选择排序",
"option_D": "直接插人排序",
"answer": "C",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "插入排序的概念",
"question": "从未排序序列中依次取出元素与已经排好序的序列中的元素作比较，将其放入已排序序列的正确位置上，此方法称为（）。",
"option_A": "插人排序",
"option_B": "选择排序",
"option_C": "交换排序",
"option_D": "归并排序",
"answer": "A",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "选择排序的概念",
"question": "从未排序序列中挑选元素，并将其放人已排序序列的一端，此方法称为（）。",
"option_A": "插入排序",
"option_B": "交换排序",
"option_C": "选择排序",
"option_D": "归并排序",
"answer": "C",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "归并排序的概念",
"question": "依次将每两个相邻的有序表合并成一个有序表的排序方法称为（）。",
"option_A": "插人排序",
"option_B": "交换排序",
"option_C": "选择排序",
"option_D": "归并排序",
"answer": "D",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "交换排序的概念",
"question": "当两个元素出现逆序的时候就交换位置，这种排序方法称为（）。",
"option_A": "插人排序",
"option_B": "交换排序",
"option_C": "选择排序",
"option_D": "归并排序",
"answer": "B",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "快速排序的概念",
"question": "每次把待排序的区间划分为左、右两个子区间，其中左区间中的记录的关键字均小于等于基准记录的关键字，右区间中记录的关键字均大于等于基准记录的关键字，这种排序称为（）。",
"option_A": "插人排序",
"option_B": "快速排序",
"option_C": "堆排序",
"option_D": "归并排序",
"answer": "B",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "插入排序的时间复杂度",
"question": "在正常情况下，直接插人排序的时间复杂度为（）。",
"option_A": "O (log2n)",
"option_B": "O (n)",
"option_C": "O (n log2n)",
"option_D": "O (n²)",
"answer": "D",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "冒泡排序的时间复杂度",
"question": "在正常情况下，冒泡排序的时间复杂度为（）。",
"option_A": "O (log2n)",
"option_B": "O (n)",
"option_C": "O (nlog2n)",
"option_D": "O (n²)",
"answer": "D",
"difficulty": 1,
"bloom_level": "a"
},
{
"knowledge_point_type": "归并排序的趟数",
"question": "在归并排序中，归并趟数的数量级为（）。",
"option_A": "O (log2n）",
"option_B": "O (n)",
"option_C": "O (nlog2n)",
"option_D": "O (n²)",
"answer": "A",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "归并排序的性能",
"question": "在归并排序中，每趟需要进行的记录比较和移动次数的数量级为（）。",
"option_A": "O (log2n）",
"option_B": "O (n)",
"option_C": "O (nlog2n)",
"option_D": "O (n²)",
"answer": "B",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "归并排序的时间复杂度",
"question": "归并排序算法时间复杂度为（）。",
"option_A": "O (log2n）",
"option_B": "O (n)",
"option_C": "O (nlog2n)",
"option_D": "O (n²)",
"answer": "C",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "快速排序的平均时间复杂度",
"question": "平均情况下，快速排序的时间复杂度为（）。",
"option_A": "O (log2n）",
"option_B": "O (n)",
"option_C": "O (nlog2n)",
"option_D": "O (n²)",
"answer": "C",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "快速排序的最坏时间复杂度",
"question": "最坏情况下，快速排序的时间复杂度为（）。",
"option_A": "O（log2n）",
"option_B": "O (n)",
"option_C": "O (nlog2n)",
"option_D": "O (n²)",
"answer": "D",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "堆排序的性能",
"question": "堆排序中，在每次筛运算中，记录比较和移动次数的数量级为（）。",
"option_A": "O（log2n）",
"option_B": "O (n)",
"option_C": "O (nlog2n)",
"option_D": "O (n²)",
"answer": "A",
"difficulty": 3,
"bloom_level": "c"
},
{
"knowledge_point_type": "堆排序的时间复杂度",
"question": "堆排序算法时间复杂度为（）。",
"option_A": "O（log2n）",
"option_B": "O (n)",
"option_C": "O (nlog2n)",
"option_D": "O (n²)",
"answer": "C",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "堆排序的应用",
"question": "设有 800 条记录，希望用最快的方法挑选出其中前 10 个最大的元素，最好选用（）。",
"option_A": "插人排序",
"option_B": "快速排序",
"option_C": "堆排序",
"option_D": "归并排序",
"answer": "C",
"difficulty": 3,
"bloom_level": "c"
},
{
"knowledge_point_type": "插入排序的最佳情况",
"question": "在待排序元素基本有序的情况下，效率最高的排序方法是（）。",
"option_A": "插入排序",
"option_B": "快速排序",
"option_C": "堆排序",
"option_D": "归并排序",
"answer": "A",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "归并排序的空间复杂度",
"question": "下面几种排序方法中，要求内存量最大的是（）。",
"option_A": "插人排序",
"option_B": "交换排序",
"option_C": "选择排序",
"option_D": "归并排序",
"answer": "D",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "排序算法的稳定性",
"question": "在下列排序方法中，关键字比较的次数与记录的初始排列秩序无关的是（）方法。",
"option_A": "希尔排序",
"option_B": "冒泡排序",
"option_C": "插人排序",
"option_D": "选择排序",
"answer": "D",
"difficulty": 3,
"bloom_level": "b"
},
{
"knowledge_point_type": "快速排序的最坏情况",
"question": "快速排序方法在（）情况下最不利于发挥其长处。",
"option_A": "要排序的数据量大大",
"option_B": "要排序的数据中含有多个相同值",
"option_C": "要排序的数据已基本有序",
"option_D": "要排序的数据个数为奇数",
"answer": "C",
"difficulty": 2,
"bloom_level": "b"
},
{
"knowledge_point_type": "二叉排序树的深度",
"question": "若构造一棵具有 n 个结点的二又树排序，在最坏的情况下，其深度不会超过（）。",
"option_A": "n/2",
"option_B": "n",
"option_C": "(n＋l)/2",
"option_D": "n＋l",
"answer": "B",
"difficulty": 3,
"bloom_level": "c"
},
{
"knowledge_point_type": "稳定排序算法",
"question": "考察下列排序算法的稳定性，（ ）是稳定的排序算法。",
"option_A": "直接插人排序、归并排序、冒泡排序",
"option_B": "简单选择排序",
"option_C": "快速排序",
"option_D": "堆排序、希尔排序",
"answer": "A",
"difficulty": 3,
"bloom_level": "c"
},
{
"knowledge_point_type": "内部排序算法的应用",
"question": "当待排序序列基本有序时，最佳的排序算法是 ()。",
"option_A": "快速排序",
"option_B": "堆排序",
"option_C": "冒泡排序",
"option_D": "归并排序",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "内部排序算法的应用",
"question": "当待排序序列长度 n 较小时，最佳的排序算法是 ()。",
"option_A": "直接插入排序",
"option_B": "快速排序",
"option_C": "堆排序",
"option_D": "归并排序",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "外部排序的基本概念",
"question": "外部排序的基本操作是 ()。",
"option_A": "归并和置换",
"option_B": "排序和合并",
"option_C": "置换 - 选择和归并",
"option_D": "索引和排序",
"answer": "C",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "多路平衡归并与败者树",
"question": "多路平衡归并中，使用败者树的目的是 ()。",
"option_A": "减少归并次数",
"option_B": "减少外存读写次数",
"option_C": "提高内排序效率",
"option_D": "减少内存占用",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "置换 - 选择排序",
"question": "置换 - 选择排序生成的初始归并段长度 ()。",
"option_A": "固定为内存工作区大小 ",
"option_B": "平均为内存工作区大小的 2 倍 ",
"option_C": "小于内存工作区大小 ",
"option_D": "大于内存工作区大小 ",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "最佳归并树",
"question": "构造最佳归并树时，应使权值 () 的叶结点尽量靠近根结点。",
"option_A": "最大",
"option_B": "最小",
"option_C": "中等",
"option_D": "任意",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "B + 树的基本概念",
"question": "m 阶 B + 树中，非叶子结点的子树个数范围是 ()。",
"option_A": "[1, m]",
"option_B": "[⌈m/2⌉, m]",
"option_C": "[⌊m/2⌋, m]",
"option_D": "[2, m]",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "外部排序的基本概念",
"question": "外部排序的主要特点是 ()。",
"option_A": "排序过程中需多次访问外存",
"option_B": "排序数据量需小于内存容量",
"option_C": "排序算法完全不需要内存参与",
"option_D": "只能对磁盘文件进行排序",
"answer": "A",
"difficulty": 3,
"bloom_level": "a"
},
{
"knowledge_point_type": "外部排序的基本步骤",
"question": "外部排序的基本步骤是 ()。",
"option_A": "生成初始归并段和多路归并",
"option_B": "排序和索引",
"option_C": "置换选择和败者树构造",
"option_D": "内排序和外排序交替进行",
"answer": "A",
"difficulty": 4,
"bloom_level": "b"
},
{
"knowledge_point_type": "置换 - 选择排序",
"question": "置换 - 选择排序生成的初始归并段的平均长度约为 ()。",
"option_A": "内存工作区大小的 1 倍",
"option_B": "内存工作区大小的 2 倍",
"option_C": "内存工作区大小的 1.5 倍",
"option_D": "与内存工作区大小无关",
"answer": "B",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "多路平衡归并与败者树",
"question": "败者树在多路归并中的主要作用是 ()。",
"option_A": "减少磁盘读写次数",
"option_B": "减少内存占用",
"option_C": "减少比较次数",
"option_D": "提高归并路数",
"answer": "C",
"difficulty": 5,
"bloom_level": "c"
},
{
"knowledge_point_type": "最佳归并树",
"question": "构造最佳归并树时，应使权值较小的叶结点尽量 () 根结点。",
"option_A": "远离",
"option_B": "靠近",
"option_C": "随机分布于",
"option_D": "位于",
"answer": "B",
"difficulty": 4,
"bloom_level": "b"
}
]
}